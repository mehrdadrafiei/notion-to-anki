Project Path: ai-tools

Source Tree:

```
ai-tools
├── pytest.ini
├── static
│   ├── js
│   │   └── flashcard_generator.js
│   └── styles
├── project_prompt.txt
├── docker
│   ├── docker-compose.yml
│   └── docker-compose.prod.yml
├── Makefile
├── setup.py
├── README.md
├── pyproject.toml
├── templates
│   └── index.html
├── monitoring
│   ├── __init__.py
│   └── health.py
├── src
│   ├── domain
│   │   ├── task
│   │   │   ├── __init__.py
│   │   │   └── service.py
│   │   ├── flashcard
│   │   │   ├── __init__.py
│   │   │   ├── models.py
│   │   │   └── service.py
│   │   ├── notion
│   │   │   ├── __init__.py
│   │   │   ├── models.py
│   │   │   ├── factory.py
│   │   │   ├── exceptions.py
│   │   │   └── service.py
│   │   └── chatbot
│   │       ├── __init__.py
│   │       ├── factory.py
│   │       ├── exceptions.py
│   │       ├── base.py
│   │       └── providers
│   │           ├── __init__.py
│   │           ├── mistral.py
│   │           └── groq.py
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── models
│   │   │   └── responses.py
│   │   ├── main.py
│   │   ├── routes
│   │   │   ├── __init__.py
│   │   │   ├── flashcard_routes.py
│   │   │   ├── health_routes.py
│   │   │   └── websocket_routes.py
│   │   └── middleware
│   │       ├── __init__.py
│   │       └── rate_limiting.py
│   ├── common
│   │   ├── __init__.py
│   │   ├── websocket.py
│   │   ├── error_handling.py
│   │   └── errors.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── error_handling.py
│   │   ├── exceptions
│   │   │   ├── domain.py
│   │   │   └── base.py
│   │   ├── container.py
│   │   ├── auth.py
│   │   ├── logging.py
│   │   └── config.py
│   ├── repositories
│   │   ├── __init__.py
│   │   └── FlashcardRepository.py
│   └── web
├── requirements
│   ├── api.txt
│   ├── test.txt
│   ├── dev.txt
│   └── base.txt
└── tests
    ├── __init__.py
    └── test_flashcard.py

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/pytest.ini`:

```ini
[pytest]
pythonpath = src
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --cov=src --cov-report=term-missing
asyncio_mode = auto
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/static/js/flashcard_generator.js`:

```js
let currentTaskId = null;
let socket = null;

function connectWebSocket(taskId) {
    if (socket) {
        socket.close();
    }

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${taskId}`;
    console.log("Connecting to WebSocket:", wsUrl);
    
    socket = new WebSocket(wsUrl);
    
    socket.onopen = function() {
        console.log("WebSocket connection established");
    };
    
    socket.onmessage = function(event) {
        console.log("WebSocket message received:", event.data);
        const data = JSON.parse(event.data);
        updateProgress(data);
    };
    
    socket.onerror = function(error) {
        console.error("WebSocket error:", error);
    };
    
    socket.onclose = function(event) {
        console.log("WebSocket connection closed:", event);
    };
    
    return socket;
}

// Function to update progress
function updateProgress(data) {
    const progressBar = document.getElementById('progress-bar');
    const progressStatus = document.getElementById('progress-status');
    const statusDiv = document.getElementById('status');
    const resultDiv = document.getElementById('result');

    // Hide the status spinner once we start getting progress
    statusDiv.classList.add('hidden');

    progressBar.style.width = `${data.progress}%`;
    progressStatus.textContent = data.message;

    if (data.status === 'completed' || data.status === 'completed_with_errors' || data.status === 'failed') {
        showDownloadButton();
        loadPreview();
        loadHistory();
        socket.close();

        // Clear progress status message
        progressStatus.textContent = '';

        // Show result message
        resultDiv.querySelector('p').textContent = data.message;
        if (data.status === 'completed') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-green-100 text-green-700';
        } else if (data.status === 'completed_with_errors') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-yellow-100 text-yellow-700';
        } else if (data.status === 'failed') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
        }
        resultDiv.classList.remove('hidden');
    }
}

// Function to show download button
function showDownloadButton() {
    const downloadSection = document.getElementById('download-section');
    downloadSection.classList.remove('hidden');
}

// Function to load preview
async function loadPreview() {
    if (!currentTaskId) return;

    try {
        const response = await fetch(`/preview-flashcards/${currentTaskId}`);
        const cards = await response.json();

        const previewSection = document.getElementById('preview-section');
        const previewCards = document.getElementById('preview-cards');
        previewCards.innerHTML = '';

        cards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = 'border rounded-md p-4';
            cardElement.innerHTML = `
                <p class="font-semibold">Front: ${card.front}</p>
                <p class="mt-2">Back: ${card.back}</p>
            `;
            previewCards.appendChild(cardElement);
        });

        previewSection.classList.remove('hidden');
    } catch (error) {
        console.error('Error loading preview:', error);
    }
}

// Function to load history
async function loadHistory() {
    try {
        const response = await fetch('/generation-history');
        const historyData = await response.json();

        let history = historyData.history ? historyData.history : historyData;

        const historyList = document.getElementById('history-list');
        if (!historyList) {
            console.error('History list element not found');
            return;
        }

        // Clear existing history
        historyList.innerHTML = '';

        // Handle empty history case
        if (!history || !Array.isArray(history) || history.length === 0) {
            historyList.innerHTML = `
                <div class="p-4 rounded-md bg-gray-100 text-gray-600 text-center">
                    <p>No flashcard generation history yet.</p>
                    <p class="text-sm mt-2">Generated flashcards will appear here.</p>
                </div>
            `;
            return;
        }

        // Sort history by timestamp in descending order
        const sortedHistory = history.sort((a, b) => 
            new Date(b.timestamp) - new Date(a.timestamp)
        );

        sortedHistory.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'border rounded-md p-4 hover:shadow-md transition-shadow duration-200';
            
            // Format the timestamp to be more readable
            const formattedDate = new Date(item.timestamp).toLocaleString(undefined, {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            historyItem.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <p class="font-semibold break-all">
                            <a href="${item.notion_page}" target="_blank" rel="noopener noreferrer">
                                ${item.notion_page}
                            </a>
                        </p>
                        <p class="text-sm text-gray-600 mt-1">${formattedDate}</p>
                        <p class="text-sm mt-1">
                            <span class="px-2 py-1 rounded ${
                                item.status === 'completed' ? 'bg-green-100 text-green-800' :
                                item.status === 'completed_with_errors' ? 'bg-yellow-100 text-yellow-800' :
                                'bg-red-100 text-red-800'
                            }">
                                ${item.status.charAt(0).toUpperCase() + item.status.slice(1)}
                            </span>
                        </p>
                    </div>
                    ${item.status !== 'failed' ? `
                        <button 
                            onclick="downloadFlashcards('${item.task_id}')"
                            class="ml-4 py-1 px-3 text-sm text-white bg-indigo-600 hover:bg-indigo-700 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                            Download
                        </button>
                    ` : ''}
                </div>
            `;
            historyList.appendChild(historyItem);
        });
    } catch (error) {
        console.error('Error loading history:', error);
        // Show error message to user
        const historyList = document.getElementById('history-list');
        if (historyList) {
            historyList.innerHTML = `
                <div class="p-4 rounded-md bg-red-100 text-red-700">
                    Failed to load history. Please try refreshing the page.
                </div>
            `;
        }
    }
}

// Function to download flashcards
async function downloadFlashcards(taskId) {
    try {
        const response = await fetch(`/download/${taskId}`);
        if (response.ok) {
            // Create a blob from the response
            const blob = await response.blob();
            // Create a temporary link element
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcards_${taskId}.csv`;
            document.body.appendChild(a);
            a.click();
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } else {
            console.error('Download failed:', await response.text());
        }

    } catch (error) {
        console.error('Error downloading flashcards:', error);
    }
}

// Main form submission handler
document.getElementById('flashcardForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const notionPage = document.getElementById('notionPage').value;
    const useChatbot = document.getElementById('useChatbot').checked;
    const chatbotType = useChatbot ? document.getElementById('chatbotType').value : null;
    const statusDiv = document.getElementById('status');
    const resultDiv = document.getElementById('result');
    const progressSection = document.getElementById('progress-section');
    const downloadSection = document.getElementById('download-section');

    // Reset UI elements
    progressSection.classList.remove('hidden');
    document.getElementById('progress-bar').style.width = '0%';
    document.getElementById('progress-status').textContent = 'Starting generation...';
    // Show loading status
    statusDiv.classList.add('hidden');
    resultDiv.classList.add('hidden');
    downloadSection.classList.add('hidden'); // Hide download button when starting new generation

    try {
        const response = await fetch('/generate-flashcards/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                notion_page: notionPage,
                use_chatbot: useChatbot,
                chatbot_type: chatbotType
            }),
        });

        const data = await response.json();
        console.log(data);

        if (response.ok) {
            currentTaskId = data.task_id;
            console.log("Task ID received:", currentTaskId);

            // Connect to WebSocket for real-time updates
            socket = connectWebSocket(currentTaskId);

            // Show loading status
            statusDiv.classList.remove('hidden');
            resultDiv.classList.add('hidden');
            downloadSection.classList.add('hidden');
        } else {
            // Handle error responses from the server
            statusDiv.classList.add('hidden');
            resultDiv.classList.remove('hidden');
            if (response.status === 429) {
                resultDiv.querySelector('p').textContent = data.error;
            } else {
                resultDiv.querySelector('p').textContent = `Error: ${data.detail}`;
            }
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
        }
    } catch (error) {
        statusDiv.classList.add('hidden');
        resultDiv.classList.remove('hidden');
        resultDiv.querySelector('p').textContent = `Error: ${error.message}`;
        resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
    }
});

document.getElementById('useChatbot').addEventListener('change', function(e) {
    const chatbotTypeContainer = document.getElementById('chatbotTypeContainer');
    const chatbotTypeSelect = document.getElementById('chatbotType');
    
    if (e.target.checked) {
        chatbotTypeContainer.classList.remove('hidden');
        chatbotTypeSelect.disabled = false;
        chatbotTypeSelect.required = true;
    } else {
        chatbotTypeContainer.classList.add('hidden');
        chatbotTypeSelect.disabled = true;
        chatbotTypeSelect.required = false;
    }
});

// Load history on page load
document.addEventListener('DOMContentLoaded', () => {
    loadHistory();
});

// Download button click handler
document.getElementById('download-btn').addEventListener('click', () => {
    if (currentTaskId) {
        downloadFlashcards(currentTaskId);
    }
});
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/project_prompt.txt`:

```txt
Project Path: ai-tools

Source Tree:

```
ai-tools
├── pytest.ini
├── static
│   ├── js
│   │   └── flashcard_generator.js
│   └── styles
├── docker-compose.yml
├── docker-compose.prod.yml
├── Makefile
├── setup.py
├── README.md
├── pyproject.toml
├── templates
│   └── index.html
├── monitoring
│   ├── __init__.py
│   └── health.py
├── src
│   ├── domain
│   │   ├── task
│   │   │   ├── __init__.py
│   │   │   └── service.py
│   │   ├── flashcard
│   │   │   ├── __init__.py
│   │   │   ├── models.py
│   │   │   └── service.py
│   │   ├── notion
│   │   │   ├── __init__.py
│   │   │   ├── models.py
│   │   │   ├── factory.py
│   │   │   ├── exceptions.py
│   │   │   └── service.py
│   │   └── chatbot
│   │       ├── __init__.py
│   │       ├── factory.py
│   │       ├── exceptions.py
│   │       ├── base.py
│   │       └── providers
│   │           ├── __init__.py
│   │           ├── mistral.py
│   │           └── groq.py
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── routes
│   │   │   ├── __init__.py
│   │   │   ├── flashcard_routes.py
│   │   │   ├── health_routes.py
│   │   │   └── websocket_routes.py
│   │   └── middleware
│   │       ├── __init__.py
│   │       └── rate_limiting.py
│   ├── common
│   │   ├── __init__.py
│   │   ├── websocket.py
│   │   ├── error_handling.py
│   │   └── errors.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── container.py
│   │   ├── auth.py
│   │   └── config.py
│   ├── repositories
│   │   ├── __init__.py
│   │   └── FlashcardRepository.py
│   └── web
├── requirements
│   ├── api.txt
│   ├── test.txt
│   ├── dev.txt
│   └── base.txt
└── tests
    ├── __init__.py
    └── test_flashcard.py

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/pytest.ini`:

```ini
[pytest]
pythonpath = src
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --cov=src --cov-report=term-missing
asyncio_mode = auto
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/static/js/flashcard_generator.js`:

```js
let currentTaskId = null;
let socket = null;

function connectWebSocket(taskId) {
    if (socket) {
        socket.close();
    }

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${taskId}`;
    console.log("Connecting to WebSocket:", wsUrl);
    
    socket = new WebSocket(wsUrl);
    
    socket.onopen = function() {
        console.log("WebSocket connection established");
    };
    
    socket.onmessage = function(event) {
        console.log("WebSocket message received:", event.data);
        const data = JSON.parse(event.data);
        updateProgress(data);
    };
    
    socket.onerror = function(error) {
        console.error("WebSocket error:", error);
    };
    
    socket.onclose = function(event) {
        console.log("WebSocket connection closed:", event);
    };
    
    return socket;
}

// Function to update progress
function updateProgress(data) {
    const progressBar = document.getElementById('progress-bar');
    const progressStatus = document.getElementById('progress-status');
    const statusDiv = document.getElementById('status');
    const resultDiv = document.getElementById('result');

    // Hide the status spinner once we start getting progress
    statusDiv.classList.add('hidden');

    progressBar.style.width = `${data.progress}%`;
    progressStatus.textContent = data.message;

    if (data.status === 'completed' || data.status === 'completed_with_errors' || data.status === 'failed') {
        showDownloadButton();
        loadPreview();
        loadHistory();
        socket.close();

        // Clear progress status message
        progressStatus.textContent = '';

        // Show result message
        resultDiv.querySelector('p').textContent = data.message;
        if (data.status === 'completed') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-green-100 text-green-700';
        } else if (data.status === 'completed_with_errors') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-yellow-100 text-yellow-700';
        } else if (data.status === 'failed') {
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
        }
        resultDiv.classList.remove('hidden');
    }
}

// Function to show download button
function showDownloadButton() {
    const downloadSection = document.getElementById('download-section');
    downloadSection.classList.remove('hidden');
}

// Function to load preview
async function loadPreview() {
    if (!currentTaskId) return;

    try {
        const response = await fetch(`/preview-flashcards/${currentTaskId}`);
        const cards = await response.json();

        const previewSection = document.getElementById('preview-section');
        const previewCards = document.getElementById('preview-cards');
        previewCards.innerHTML = '';

        cards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = 'border rounded-md p-4';
            cardElement.innerHTML = `
                <p class="font-semibold">Front: ${card.front}</p>
                <p class="mt-2">Back: ${card.back}</p>
            `;
            previewCards.appendChild(cardElement);
        });

        previewSection.classList.remove('hidden');
    } catch (error) {
        console.error('Error loading preview:', error);
    }
}

// Function to load history
async function loadHistory() {
    try {
        const response = await fetch('/generation-history');
        const historyData = await response.json();

        let history = historyData.history ? historyData.history : historyData;

        const historyList = document.getElementById('history-list');
        if (!historyList) {
            console.error('History list element not found');
            return;
        }

        // Clear existing history
        historyList.innerHTML = '';

        // Handle empty history case
        if (!history || !Array.isArray(history) || history.length === 0) {
            historyList.innerHTML = `
                <div class="p-4 rounded-md bg-gray-100 text-gray-600 text-center">
                    <p>No flashcard generation history yet.</p>
                    <p class="text-sm mt-2">Generated flashcards will appear here.</p>
                </div>
            `;
            return;
        }

        // Sort history by timestamp in descending order
        const sortedHistory = history.sort((a, b) => 
            new Date(b.timestamp) - new Date(a.timestamp)
        );

        sortedHistory.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'border rounded-md p-4 hover:shadow-md transition-shadow duration-200';
            
            // Format the timestamp to be more readable
            const formattedDate = new Date(item.timestamp).toLocaleString(undefined, {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            historyItem.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <p class="font-semibold break-all">
                            <a href="${item.notion_page}" target="_blank" rel="noopener noreferrer">
                                ${item.notion_page}
                            </a>
                        </p>
                        <p class="text-sm text-gray-600 mt-1">${formattedDate}</p>
                        <p class="text-sm mt-1">
                            <span class="px-2 py-1 rounded ${
                                item.status === 'completed' ? 'bg-green-100 text-green-800' :
                                item.status === 'completed_with_errors' ? 'bg-yellow-100 text-yellow-800' :
                                'bg-red-100 text-red-800'
                            }">
                                ${item.status.charAt(0).toUpperCase() + item.status.slice(1)}
                            </span>
                        </p>
                    </div>
                    ${item.status !== 'failed' ? `
                        <button 
                            onclick="downloadFlashcards('${item.task_id}')"
                            class="ml-4 py-1 px-3 text-sm text-white bg-indigo-600 hover:bg-indigo-700 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                            Download
                        </button>
                    ` : ''}
                </div>
            `;
            historyList.appendChild(historyItem);
        });
    } catch (error) {
        console.error('Error loading history:', error);
        // Show error message to user
        const historyList = document.getElementById('history-list');
        if (historyList) {
            historyList.innerHTML = `
                <div class="p-4 rounded-md bg-red-100 text-red-700">
                    Failed to load history. Please try refreshing the page.
                </div>
            `;
        }
    }
}

// Function to download flashcards
async function downloadFlashcards(taskId) {
    try {
        const response = await fetch(`/download/${taskId}`);
        if (response.ok) {
            // Create a blob from the response
            const blob = await response.blob();
            // Create a temporary link element
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcards_${taskId}.csv`;
            document.body.appendChild(a);
            a.click();
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } else {
            console.error('Download failed:', await response.text());
        }

    } catch (error) {
        console.error('Error downloading flashcards:', error);
    }
}

// Main form submission handler
document.getElementById('flashcardForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const notionPage = document.getElementById('notionPage').value;
    const useChatbot = document.getElementById('useChatbot').checked;
    const chatbotType = useChatbot ? document.getElementById('chatbotType').value : null;
    const statusDiv = document.getElementById('status');
    const resultDiv = document.getElementById('result');
    const progressSection = document.getElementById('progress-section');
    const downloadSection = document.getElementById('download-section');

    // Reset UI elements
    progressSection.classList.remove('hidden');
    document.getElementById('progress-bar').style.width = '0%';
    document.getElementById('progress-status').textContent = 'Starting generation...';
    // Show loading status
    statusDiv.classList.add('hidden');
    resultDiv.classList.add('hidden');
    downloadSection.classList.add('hidden'); // Hide download button when starting new generation

    try {
        const response = await fetch('/generate-flashcards/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                notion_page: notionPage,
                use_chatbot: useChatbot,
                chatbot_type: chatbotType
            }),
        });

        const data = await response.json();
        console.log(data);

        if (response.ok) {
            currentTaskId = data.task_id;
            console.log("Task ID received:", currentTaskId);

            // Connect to WebSocket for real-time updates
            socket = connectWebSocket(currentTaskId);

            // Show loading status
            statusDiv.classList.remove('hidden');
            resultDiv.classList.add('hidden');
            downloadSection.classList.add('hidden');
        } else {
            // Handle error responses from the server
            statusDiv.classList.add('hidden');
            resultDiv.classList.remove('hidden');
            if (response.status === 429) {
                resultDiv.querySelector('p').textContent = data.error;
            } else {
                resultDiv.querySelector('p').textContent = `Error: ${data.detail}`;
            }
            resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
        }
    } catch (error) {
        statusDiv.classList.add('hidden');
        resultDiv.classList.remove('hidden');
        resultDiv.querySelector('p').textContent = `Error: ${error.message}`;
        resultDiv.querySelector('div').className = 'p-4 rounded-md bg-red-100 text-red-700';
    }
});

document.getElementById('useChatbot').addEventListener('change', function(e) {
    const chatbotTypeContainer = document.getElementById('chatbotTypeContainer');
    const chatbotTypeSelect = document.getElementById('chatbotType');
    
    if (e.target.checked) {
        chatbotTypeContainer.classList.remove('hidden');
        chatbotTypeSelect.disabled = false;
        chatbotTypeSelect.required = true;
    } else {
        chatbotTypeContainer.classList.add('hidden');
        chatbotTypeSelect.disabled = true;
        chatbotTypeSelect.required = false;
    }
});

// Load history on page load
document.addEventListener('DOMContentLoaded', () => {
    loadHistory();
});

// Download button click handler
document.getElementById('download-btn').addEventListener('click', () => {
    if (currentTaskId) {
        downloadFlashcards(currentTaskId);
    }
});
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/docker-compose.yml`:

```yml
version: '3.8'
services:
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
    command: redis-server
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/docker-compose.prod.yml`:

```yml
version: '3.8'
services:
  redis-node1:
    image: bitnami/redis-cluster:latest
    environment:
      - REDIS_NODES=3
    ports:
      - "7001:7001"

  redis-node2:
    image: bitnami/redis-cluster:latest
    ports:
      - "7002:7002"

  redis-node3:
    image: bitnami/redis-cluster:latest
    ports:
      - "7003:7003"
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/Makefile`:

```
.PHONY: test test-cov test-html clean

test:
	pytest -v

test-cov:
	pytest --cov=. --cov-report=term-missing

test-html:
	pytest --cov=. --cov-report=html

clean:
	rm -rf .coverage htmlcov .pytest_cache __pycache__

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/setup.py`:

```py
from setuptools import find_packages, setup

setup(
    name="notion2anki",
    version="0.1",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/README.md`:

```md
Create Anki flashcards from the Notion content!

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/pyproject.toml`:

```toml
[tool.black]
line-length = 120
target-version = ["py312"]
skip-string-normalization = true

[tool.isort]
profile = "black"
line_length = 120
sections = ["FUTURE", "STDLIB", "THIRDPARTY", "FIRSTPARTY", "LOCALFOLDER"]

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/templates/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="min-h-screen p-8">
        <div class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Generator Form -->
            <div class="bg-white p-8 rounded-lg shadow-md h-full">
                <h1 class="text-2xl font-bold mb-6 text-center">Flashcard Generator</h1>
                
                <form id="flashcardForm" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Notion Page URL or ID</label>
                        <input type="text" id="notionPage" required
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700">
                            <input type="checkbox" id="useChatbot" class="mr-2">
                            Use chatbot to summarize answer
                        </label>
                    </div>
                    
                    <div id="chatbotTypeContainer" class="hidden">
                        <label class="block text-sm font-medium text-gray-700">Chatbot Type</label>
                        <select id="chatbotType" disabled
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                            {% for type in chatbot_types %}
                                <option value="{{ type }}">{{ type|title }}</option>
                            {% endfor %}
                        </select>
                    </div>                

                    <button type="submit"
                            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Generate Flashcards
                    </button>
                </form>

                <!-- Progress Section -->
                <div id="progress-section" class="mt-6 hidden">
                    <h2 class="text-lg font-semibold mb-2">Generation Progress</h2>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <p id="progress-status" class="mt-2 text-sm text-gray-600"></p>
                </div>

                <!-- Status and Result -->
                <div id="status" class="mt-4 hidden">
                    <div class="flex items-center justify-center">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                        <span class="ml-2">Generating flashcards...</span>
                    </div>
                </div>

                <div id="result" class="mt-4 hidden">
                    <div class="p-4 rounded-md">
                        <p class="text-sm"></p>
                    </div>
                </div>

                <!-- Download Button -->
                <div id="download-section" class="mt-4 hidden">
                    <button id="download-btn" class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700">
                        Download Flashcards
                    </button>
                </div>
            </div>

            <!-- Preview and History Section -->
            <div class="space-y-8">
                <!-- Preview Section -->
                <div id="preview-section" class="bg-white p-8 rounded-lg shadow-md hidden">
                    <h2 class="text-xl font-bold mb-4">Preview</h2>
                    <div id="preview-cards" class="space-y-4">
                        <!-- Preview cards will be inserted here -->
                    </div>
                </div>

                <!-- History Section -->
                <div class="bg-white p-8 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold mb-4">Generation History</h2>
                    <div id="history-list" class="space-y-4">
                        <!-- History items will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/static/js/flashcard_generator.js"></script>
    
</body>
</html>
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/monitoring/health.py`:

```py
# monitoring/health.py
from dataclasses import dataclass
from typing import Any, Dict, Optional

import httpx
from fastapi import HTTPException, Request, Response
from fastapi.responses import JSONResponse

from src.core.config import settings
from src.domain.chatbot.factory import ChatBotFactory


@dataclass
class ServiceHealth:
    notion_api: bool
    chatbots: Dict[str, bool]


class HealthCheck:
    """Health check service for APIs"""

    def __init__(self):
        self.client = httpx.AsyncClient()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.client.aclose()

    async def _check_notion_api(self) -> bool:
        """Check the health of the Notion API."""
        try:
            response = await self.client.get(
                "https://api.notion.com/v1/users/me",
                headers={"Authorization": f"Bearer {settings.notion_api_key}", "Notion-Version": "2022-06-28"},
            )
            return response.status_code == 200
        except Exception:
            return False

    async def _check_chatbots(self) -> Dict[str, bool]:
        """Check the health of all available chatbots."""
        chatbot_health = {}
        for chatbot_type in ChatBotFactory.get_available_chatbots():
            try:
                chatbot = await ChatBotFactory.create(chatbot_type)
                summary = await chatbot.get_summary("Just say hi!")
                chatbot_health[chatbot_type] = summary is not None
                await chatbot.cleanup()
            except Exception:
                chatbot_health[chatbot_type] = False
        return chatbot_health

    async def check_services(self) -> Dict[str, Any]:
        """Perform health checks for all services."""
        health_status = {
            "notion_api": await self._check_notion_api(),
            "chatbots": await self._check_chatbots(),
        }
        return ServiceHealth(**health_status).__dict__

    async def get_health(self, request: Request):
        """Endpoint to return the health status of all services."""
        health_check = await self.check_services()
        status = "healthy" if all(health_check.values()) else "unhealthy"
        return JSONResponse(
            content={"status": status, "services": health_check}, status_code=200 if status == "healthy" else 503
        )

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/task/service.py`:

```py
# src/services/task_service.py
import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional

from fastapi import HTTPException
from redis.asyncio import Redis

from src.common.websocket import WebSocketManager

logger = logging.getLogger(__name__)


class TaskService:
    def __init__(self, redis: Redis, websocket_manager: WebSocketManager):
        self.redis = redis
        self.websocket_manager = websocket_manager
        self._lock = asyncio.Lock()  # Add lock for Redis operations

    async def create_task(self, user_id: str, task_id: str, initial_data: Dict) -> None:
        """Create a new task with initial data."""
        task_key = f"task:{user_id}:{task_id}"
        task_data = {**initial_data, "timestamp": datetime.now().isoformat(), "user_id": user_id}

        try:
            async with self._lock:  # Use lock for Redis operations
                # Store task data with 24-hour TTL
                await self.redis.setex(task_key, 86400, json.dumps(task_data))  # 24 hours
        except Exception as e:
            logger.error(f"Failed to create task {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to create task")

    async def update_task_progress(self, user_id: str, task_id: str, progress: int, status: str, message: str) -> None:
        """Update task progress and notify via WebSocket."""
        task_key = f"task:{user_id}:{task_id}"

        try:
            async with self._lock:  # Use lock for Redis operations
                # Get existing task data
                existing_data = await self.redis.get(task_key)
                if existing_data:
                    task_data = json.loads(existing_data)
                else:
                    task_data = {}

                # Update task data
                task_data.update(
                    {
                        "progress": progress,
                        "status": status,
                        "message": message,
                        "timestamp": datetime.now().isoformat(),
                        "user_id": user_id,
                    }
                )

                # Store updated data
                await self.redis.setex(task_key, 86400, json.dumps(task_data))  # 24 hours

            # Send WebSocket update outside the lock
            try:
                await self.websocket_manager.send_progress(task_id, task_data)
            except Exception as ws_error:
                logger.error(f"WebSocket error for task {task_id}: {ws_error}")

        except Exception as e:
            logger.error(f"Failed to update task {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to update task status")

    async def get_task_status(self, user_id: str, task_id: str) -> Dict:
        """Get current task status."""
        task_key = f"task:{user_id}:{task_id}"

        try:
            task_data = await self.redis.get(task_key)
            if not task_data:
                raise HTTPException(status_code=404, detail="Task not found")

            return json.loads(task_data)

        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to get task status for {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to get task status")

    async def add_to_history(self, user_id: str, task_details: Dict) -> None:
        """Add completed task to user's history."""
        history_key = f"history:{user_id}"

        try:
            # Add to sorted set with timestamp as score
            timestamp = datetime.fromisoformat(task_details['timestamp']).timestamp()

            await self.redis.zadd(history_key, {json.dumps(task_details): timestamp})

            # Trim history to last 100 entries
            await self.redis.zremrangebyrank(history_key, 0, -101)

            # Set 30-day TTL for history
            await self.redis.expire(history_key, 2592000)

        except Exception as e:
            logger.error(f"Failed to add task to history for user {user_id}: {e}")
            # Non-critical operation, log error but don't raise exception

    async def get_user_history(self, user_id: str, limit: int = 50) -> List[Dict]:
        """Get user's task history."""
        history_key = f"history:{user_id}"

        try:
            # Get history entries sorted by timestamp
            entries = await self.redis.zrevrange(history_key, 0, limit - 1)

            return [json.loads(entry) for entry in entries]

        except Exception as e:
            logger.error(f"Failed to get history for user {user_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to retrieve task history")

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/flashcard/models.py`:

```py
from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class Flashcard:
    """Domain model representing a Flashcard."""

    front: str
    back: str
    url: Optional[str] = None
    tags: Optional[List[str]] = field(default_factory=list)
    created_at: Optional[str] = None

    def __post_init__(self):
        """Validate flashcard data after initialization."""
        if not self.front or not self.back:
            raise ValueError("Flashcard must have both front and back content")

        # Trim excessive whitespace
        self.front = self.front.strip()
        self.back = self.back.strip()
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/flashcard/service.py`:

```py
import asyncio
import logging
import time
from functools import wraps
from typing import Callable, Dict, List, Optional, Union

from cachetools import TTLCache
from tenacity import retry, stop_after_attempt, wait_exponential

from src.core.config import settings
from src.domain.task.service import TaskService

from ...repositories.FlashcardRepository import Flashcard, FlashcardRepositoryInterface
from ..chatbot.base import ChatBot


class FlashcardValidator:
    """Validates flashcard content integrity."""

    @staticmethod
    def validate_flashcard_content(text: str, min_length: int = 3, max_length: int = 500) -> bool:
        """
        Validate flashcard content.

        Args:
            text (str): Text to validate
            min_length (int, optional): Minimum text length. Defaults to 3.
            max_length (int, optional): Maximum text length. Defaults to 500.

        Returns:
            bool: Whether the text meets validation criteria
        """
        if not text or not isinstance(text, str):
            return False

        text = text.strip()
        if not text or text == "Summary unavailable":
            return False

        return min_length <= len(text) <= max_length and text.strip() != "None"


class FlashcardCache:
    """Manage time-limited caching for flashcard summaries."""

    def __init__(self, maxsize: int = 100, ttl: int = 3600):
        """
        Initialize the cache.

        Args:
            maxsize (int, optional): Maximum cache size. Defaults to 100.
            ttl (int, optional): Time-to-live in seconds. Defaults to 3600.
        """
        self.cache = TTLCache(maxsize=maxsize, ttl=ttl)

    def get(self, key: str) -> Optional[str]:
        """
        Retrieve value from cache.

        Args:
            key (str): Cache key

        Returns:
            Optional[str]: Cached value or None
        """
        return self.cache.get(key)

    def set(self, key: str, value: str) -> None:
        """
        Set value in cache.

        Args:
            key (str): Cache key
            value (str): Value to cache
        """
        self.cache[key] = value


def rate_limit(calls: int, period: int):
    """
    Decorator to rate limit async function calls.

    Args:
        calls (int): Maximum number of calls
        period (int): Time period in seconds

    Returns:
        Callable: Decorated function
    """
    min_interval = period / calls
    last_called = [0.0]

    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            if elapsed < min_interval:
                await asyncio.sleep(min_interval - elapsed)
            last_called[0] = time.time()
            return await func(*args, **kwargs)

        return wrapper

    return decorator


class FlashcardCreator:
    """
    Manages the creation of flashcards from various content sources.
    """

    PROMPT_PREFIX = (
        "Summarize the following text for the back of an Anki flashcard. "
        "Provide only the summary, enclosed in [[ ]]: \n"
    )

    def __init__(
        self,
        flashcard_repository: FlashcardRepositoryInterface,
        cache: Optional[FlashcardCache] = None,
        task_service: Optional[TaskService] = None,
        task_id: str = None,
        user_id: str = None,
    ):
        """
        Initialize FlashcardCreator.

        Args:
            flashcard_repository (FlashcardRepositoryInterface): Repository to save flashcards
            cache (Optional[FlashcardCache], optional): Cache for summaries. Defaults to None.
        """
        self.flashcard_repository = flashcard_repository
        self.cache = cache or FlashcardCache(maxsize=settings.cache_maxsize, ttl=settings.cache_expiry)
        self.progress_callback: Optional[Callable] = None
        self.task_service = task_service
        self.logger = logging.getLogger(__name__)
        self.task_id = task_id
        self.user_id = user_id

    @retry(stop=stop_after_attempt(settings.max_retries), wait=wait_exponential(multiplier=1, min=4, max=10))
    @rate_limit(calls=settings.rate_limit_calls, period=settings.rate_limit_period)
    async def get_cached_summary(self, text: str, chatbot: Optional[ChatBot] = None) -> str:
        """
        Generate or retrieve a cached summary for given text.

        Args:
            text (str): Text to summarize
            chatbot (Optional[ChatBot], optional): Chatbot for generating summary

        Returns:
            str: Generated or cached summary
        """
        prompt = f"{self.PROMPT_PREFIX} {text}"
        cache_key = f"summary_{hash(prompt)}"

        # Check cache first
        cached_summary = self.cache.get(cache_key)
        if cached_summary:
            self.logger.info(f"Cache hit for prompt: {text[:50]}...")
            return cached_summary

        # Generate summary if chatbot available
        if not chatbot:
            return text

        try:
            summary = await chatbot.get_summary(prompt)

            if summary:
                self.cache.set(cache_key, summary)
                return summary
            return None
        except Exception as e:
            self.logger.error(f"Error getting summary: {e}")
            return None

    async def create_flashcards(
        self, notion_content: List[Dict[str, str]], chatbot: Optional[ChatBot] = None, batch_size: int = 10
    ) -> Union[str, str]:
        """
        Create flashcards from provided content.

        Args:
            headings_and_bullets (List[Dict[str, str]]): Content to convert to flashcards
            chatbot (Optional[ChatBot], optional): Chatbot for summary generation
            batch_size (int, optional): Number of flashcards to process in batch
        """
        self.logger.info(f"Starting flashcard creation for {len(notion_content)} items")

        # Retrieve existing flashcards to avoid duplicates
        existing_flashcards = await self.flashcard_repository.get_existing_flashcards()
        total_items = len(notion_content)
        processed_items = 0
        skipped_items = 0

        for item in notion_content:
            processed_items += 1

            # Create flashcard
            card = Flashcard(front=item["front"], back=item["back"], url=item["url"])

            # Skip existing flashcards
            if card.front in existing_flashcards:
                skipped_items += 1
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="processing",
                        message=f"Skipped existing flashcard ({processed_items}/{total_items})",
                    )
                self.logger.info(f"Skipping existing flashcard: {card.front[:50]}...")
                await asyncio.sleep(0.1)
                continue

            # Validate content
            if not FlashcardValidator.validate_flashcard_content(card.front):
                skipped_items += 1
                self.logger.warning(f"Invalid content skipped: {card.front[:50]}...")
                continue

            try:
                if chatbot:
                    # Try to get summary, skip if it fails
                    summary = await self.get_cached_summary(card.back, chatbot)
                    if summary is None:
                        skipped_items += 1
                        if self.task_service:
                            await self.task_service.update_task_progress(
                                user_id=self.user_id,
                                task_id=self.task_id,
                                progress=int((processed_items / total_items) * 100),
                                status="warning",
                                message=f"Skipped flashcard due to summarization failure ({skipped_items} skipped)",
                            )
                        self.logger.warning(f"Skipping flashcard due to summarization failure: {card.front[:50]}...")
                        continue

                    card.back = summary

                # Append URL to back content
                card.back += f'\n URL: <a href="{item["url"]}">Link</a>'

                # Save flashcard
                await self.flashcard_repository.save_flashcard(card)

                # Update progress after saving
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="processing",
                        message=f"Created flashcard ({processed_items}/{total_items})",
                    )

                self.logger.info(f"Created flashcard: {card.front[:50]}...")
                await asyncio.sleep(0.1)

            except Exception as e:
                skipped_items += 1
                self.logger.error(f"Error processing flashcard: {str(e)}")
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="warning",
                        message=f"Error with flashcard ({processed_items}/{total_items}): {str(e)}",
                    )
                await asyncio.sleep(0.1)

        # Final progress update
        if self.task_service:
            if skipped_items == total_items:
                message = "All flashcards failed to generate"
                status = "failed"
            elif skipped_items > 0:
                message = f"Flashcard generation completed with {processed_items - skipped_items} successful and {skipped_items} failed"
                status = "completed_with_errors"
            else:
                message = f"Flashcard generation completed successfully for all {total_items} flashcards"
                status = "completed"

            await self.task_service.update_task_progress(
                user_id=self.user_id,
                task_id=self.task_id,
                progress=100,
                status=status,
                message=message,
            )
        self.logger.info(f"Flashcard creation completed in '{self.flashcard_repository.anki_output_file}'")

        return message, status


class FlashcardService:
    """Orchestrates the flashcard creation process."""

    def __init__(
        self,
        flashcard_creator: FlashcardCreator,
        notion_content: List[Dict[str, str]],
        chatbot: Optional[ChatBot] = None,
    ):
        """
        Initialize FlashcardService.

        Args:
            flashcard_creator (FlashcardCreator): Creator to generate flashcards
            notion_content (List[Dict[str, str]]): Content to convert to flashcards
            chatbot (Optional[ChatBot], optional): Chatbot for summary generation
        """
        self.flashcard_creator = flashcard_creator
        self.notion_content = notion_content
        self.chatbot = chatbot
        self.logger = logging.getLogger(__name__)

    async def run(self) -> Union[str, str]:
        """Execute flashcard creation process."""
        try:
            return await self.flashcard_creator.create_flashcards(self.notion_content, self.chatbot)
        except Exception as e:
            self.logger.error(f"Error in flashcard creation: {e}")
            raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/models.py`:

```py
from dataclasses import dataclass
from enum import Enum, auto
from typing import Optional, List, Dict


class BlockType(Enum):
    """Enumeration of supported Notion block types."""
    HEADING_1 = auto()
    HEADING_2 = auto()
    HEADING_3 = auto()
    BULLETED_LIST_ITEM = auto()
    PARAGRAPH = auto()

    @classmethod
    def is_heading(cls, block_type: 'BlockType') -> bool:
        """Check if the block type is a heading."""
        return block_type in {cls.HEADING_1, cls.HEADING_2, cls.HEADING_3}


@dataclass
class NotionBlock:
    """Domain model representing a Notion block with structured information."""
    type: BlockType
    text: str
    url: str
    nested_text: Optional[str] = None

    @property
    def is_heading(self) -> bool:
        """Check if the block is a heading."""
        return BlockType.is_heading(self.type)

    @property
    def to_flashcard_dict(self) -> Dict[str, str]:
        """Convert block to flashcard dictionary format."""
        return {
            "front": self.text,
            "back": self.nested_text or self.text,
            "url": self.url
        }

    @classmethod
    def from_block_data(cls, block: Dict, base_url: str, nested_text: Optional[str] = None) -> Optional['NotionBlock']:
        """
        Factory method to create NotionBlock from Notion API block data.

        Args:
            block (Dict): Raw block data from Notion API
            base_url (str): Base URL of the Notion page
            nested_text (Optional[str]): Nested content text

        Returns:
            Optional[NotionBlock]: Parsed Notion block or None if unsupported
        """
        block_type = block['type']
        block_id = block['id'].replace("-", "")

        try:
            if block_type in ['heading_1', 'heading_2', 'heading_3']:
                return cls(
                    type=BlockType[block_type.upper().replace('heading_', 'HEADING_')],
                    text=block[block_type]['text'][0]['text']['content'],
                    url=f"{base_url}#{block_id}",
                )
            elif block_type == 'bulleted_list_item':
                return cls(
                    type=BlockType.BULLETED_LIST_ITEM,
                    text=block['bulleted_list_item']['rich_text'][0]['text']['content'],
                    url=f"{base_url}#{block_id}",
                    nested_text=nested_text,
                )
            return None

        except (KeyError, IndexError) as e:
            return None


@dataclass
class NotionPage:
    """Domain model representing a Notion page."""
    id: str
    url: Optional[str]
    blocks: List[NotionBlock]

    @property
    def to_flashcard_format(self) -> List[Dict[str, str]]:
        """Convert page blocks to flashcard format."""
        return [block.to_flashcard_dict for block in self.blocks 
                if block and block.type in {BlockType.HEADING_1, BlockType.HEADING_2, 
                                          BlockType.HEADING_3, BlockType.BULLETED_LIST_ITEM}]
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/factory.py`:

```py
from typing import Optional
from .service import NotionService
from src.core.config import settings


async def create_notion_service(api_key: Optional[str] = None) -> NotionService:
    """
    Factory function to create a NotionService instance.

    Args:
        api_key (Optional[str]): Optional API key override

    Returns:
        NotionService: Configured Notion service
    """
    service = NotionService(api_key or settings.notion_api_key)
    return service

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/exceptions.py`:

```py
class NotionServiceError(Exception):
    """Base exception for Notion service-related errors."""
    
    def __init__(self, message: str):
        self.message = message
        super().__init__(self.message)


class NotionAuthenticationError(NotionServiceError):
    """Raised when there are authentication issues with Notion API."""
    pass


class NotionPageNotFoundError(NotionServiceError):
    """Raised when a Notion page cannot be found."""
    pass


class NotionContentError(NotionServiceError):
    """Raised when there are issues processing Notion content."""
    pass
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/service.py`:

```py
import re
import logging
from typing import List, Optional, Dict
import asyncio
from notion_client import AsyncClient
from notion_client.errors import APIResponseError, HTTPResponseError

from src.core.config import settings
from src.common.error_handling import handle_errors_decorator
from .models import NotionBlock, NotionPage
from .exceptions import NotionServiceError

logger = logging.getLogger(__name__)


class NotionService:
    """Service class for interacting with Notion API."""

    def __init__(self, api_key: Optional[str] = None):
        """Initialize NotionService with API key."""
        self.client = AsyncClient(auth=api_key or settings.notion_api_key)
        self._url_cache: Dict[str, str] = {}

    @staticmethod
    def extract_page_id(page_id_or_url: str) -> str:
        """
        Extract the page ID from a Notion page URL or return the input if it's already a page ID.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            str: Extracted page ID
        """
        if page_id_or_url.startswith(("https://www.notion.so/", "https://notion.so/")):
            match = re.search(r"[a-f0-9]{32}", page_id_or_url)
            if match:
                return match.group()
        return page_id_or_url

    @handle_errors_decorator(
        default_return_value=None,
        exceptions=(APIResponseError, HTTPResponseError),
        message="Error retrieving page URL from Notion"
    )
    async def get_page_url(self, page_id: str) -> Optional[str]:
        """
        Retrieve the URL of the Notion page.

        Args:
            page_id (str): Notion page ID

        Returns:
            Optional[str]: The URL of the page or None if retrieval fails
        """
        if page_id in self._url_cache:
            return self._url_cache[page_id]

        page_content = await self.client.pages.retrieve(page_id=page_id)
        url = page_content.get("url")
        if url:
            self._url_cache[page_id] = url
        return url

    def _extract_nested_text(self, children: List[Dict]) -> str:
        """
        Extract text from child blocks.

        Args:
            children (List[Dict]): List of child blocks

        Returns:
            str: Concatenated text from child blocks
        """
        texts = []
        supported_types = ['paragraph', 'bulleted_list_item', 'heading_1', 'heading_2', 'heading_3']

        for child in children:
            block_type = child['type']
            if block_type in supported_types:
                try:
                    text = child[block_type]['rich_text'][0]['text']['content']
                    texts.append(text)
                except (KeyError, IndexError):
                    continue

        return "\n".join(texts)

    async def _process_block(self, block: Dict, base_url: str) -> Optional[NotionBlock]:
        """
        Process a single block, including nested content.

        Args:
            block (Dict): Notion block to process
            base_url (str): Base URL of the page

        Returns:
            Optional[NotionBlock]: Processed block
        """
        nested_text = ""
        if block.get('has_children', False):
            nested_blocks = await self.client.blocks.children.list(block_id=block['id'])
            nested_text = self._extract_nested_text(nested_blocks.get('results', []))

        return NotionBlock.from_block_data(block, base_url=base_url, nested_text=nested_text)

    @handle_errors_decorator(
        default_return_value=[],
        exceptions=(APIResponseError, HTTPResponseError),
        message="Error retrieving blocks from Notion"
    )
    async def get_page_content(self, page_id_or_url: str) -> NotionPage:
        """
        Retrieve and process all content from a Notion page.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            NotionPage: Processed page content

        Raises:
            NotionServiceError: If page content cannot be retrieved
        """
        page_id = self.extract_page_id(page_id_or_url)
        url = await self.get_page_url(page_id)
        
        if not url:
            raise NotionServiceError(f"Could not retrieve URL for page {page_id}")

        blocks_response = await self.client.blocks.children.list(block_id=page_id)
        results = blocks_response.get('results', [])

        # Process blocks concurrently
        tasks = [self._process_block(block, url) for block in results]
        processed_blocks = await asyncio.gather(*tasks)

        # Filter out None values
        valid_blocks = [block for block in processed_blocks if block is not None]

        return NotionPage(id=page_id, url=url, blocks=valid_blocks)

    async def get_flashcards(self, page_id_or_url: str) -> List[Dict[str, str]]:
        """
        Get page content in flashcard format.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            List[Dict[str, str]]: List of flashcard dictionaries
        """
        page = await self.get_page_content(page_id_or_url)
        return page.to_flashcard_format
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/factory.py`:

```py
from typing import Dict, Type

from .base import ChatBot
from .exceptions import ChatBotNotFoundError
from .providers.groq import GroqChatBot
from .providers.mistral import MistralChatBot


class ChatBotFactory:
    """Factory class for creating chatbot instances"""

    _chatbots: Dict[str, Type[ChatBot]] = {'groq': GroqChatBot, 'mistral': MistralChatBot}

    @classmethod
    async def create(cls, chatbot_type: str) -> ChatBot:
        """
        Create and initialize a chatbot instance

        Args:
            chatbot_type: The type of chatbot to create

        Returns:
            An initialized chatbot instance

        Raises:
            ChatBotNotFoundError: If the requested chatbot type is not supported
        """
        chatbot_class = cls._chatbots.get(chatbot_type.lower())
        if not chatbot_class:
            raise ChatBotNotFoundError(
                f"Unsupported chatbot type: {chatbot_type}. " f"Available types: {list(cls._chatbots.keys())}"
            )

        chatbot = chatbot_class()
        await chatbot.initialize()
        return chatbot

    @classmethod
    def register_chatbot(cls, name: str, chatbot_class: Type[ChatBot]) -> None:
        """
        Register a new chatbot type

        Args:
            name: The name to register the chatbot under
            chatbot_class: The chatbot class to register
        """
        cls._chatbots[name.lower()] = chatbot_class

    @classmethod
    def get_available_chatbots(cls) -> list[str]:
        """Get a list of all available chatbot types"""
        return list(cls._chatbots.keys())

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/exceptions.py`:

```py
class ChatBotError(Exception):
    """Base exception for all chatbot-related errors"""

    pass


class ChatBotNotFoundError(ChatBotError):
    """Raised when a requested chatbot type is not found"""

    pass


class ChatBotInitializationError(ChatBotError):
    """Raised when a chatbot fails to initialize"""

    pass


class ChatBotAPIError(ChatBotError):
    """Raised when there's an error communicating with the chatbot API"""

    pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/base.py`:

```py
import logging
import re
from abc import ABC, abstractmethod
from functools import wraps
from typing import Optional

logger = logging.getLogger(__name__)


def handle_errors(
    default_return_value: Optional[str] = None,
    exceptions: tuple = (Exception,),
    message: str = "Error in chatbot operation",
):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except exceptions as e:
                logger.error(f"{message}: {str(e)}")
                return default_return_value

        return wrapper

    return decorator


class ChatBot(ABC):
    """Abstract base class for all chatbot implementations"""

    @abstractmethod
    async def initialize(self) -> None:
        """Initialize any necessary clients or resources"""
        pass

    @abstractmethod
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        """Generate a summary from the given prompt"""
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup any resources"""
        pass

    @handle_errors(exceptions=(AttributeError, IndexError), message="Error processing response")
    async def process_response(self, response) -> Optional[str]:
        """
        Process the API response, returning None if the summary is invalid or empty.
        """
        if not response or not hasattr(response, 'choices'):
            return None

        content = response.choices[0].message.content
        if not content:
            return None

        pattern = r"\[\[(.*?)\]\]"  # Matches the content within [[ ]]
        find_match = re.findall(pattern, content)

        if find_match:
            summary = find_match[0].strip()
            return summary if summary else None
        else:
            # If no brackets found, use the whole content if it's not empty
            content = content.strip()
            return content if content else None

    async def __aenter__(self):
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/providers/mistral.py`:

```py
from typing import Optional

from mistralai import Mistral

from src.core.config import settings

from ..base import ChatBot, handle_errors


class MistralChatBot(ChatBot):
    def __init__(self):
        self.client: Optional[Mistral] = None
        self.default_model = "mistral-large-latest"

    async def initialize(self) -> None:
        self.client = Mistral(api_key=settings.mistral_api_key)

    @handle_errors(message="MistralChatBot failed to summarize")
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        if not self.client:
            await self.initialize()

        summary = await self.client.chat.complete_async(
            model=model or self.default_model,
            messages=[{"role": "user", "content": prompt}],
        )
        return await self.process_response(summary)

    async def cleanup(self) -> None:
        pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/providers/groq.py`:

```py
from typing import Optional

from groq import AsyncGroq

from src.core.config import settings

from ..base import ChatBot, handle_errors


class GroqChatBot(ChatBot):
    def __init__(self):
        self.client: Optional[AsyncGroq] = None
        self.default_model = "llama-3.1-8b-instant"

    async def initialize(self) -> None:
        self.client = AsyncGroq(api_key=settings.groq_api_key)

    @handle_errors(message="GroqChatBot failed to summarize")
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        if not self.client:
            await self.initialize()

        summary = await self.client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model=model or self.default_model,
        )
        return await self.process_response(summary)

    async def cleanup(self) -> None:
        if self.client:
            await self.client.close()
            self.client = None

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/__init__.py`:

```py
from .domain.flashcard.service import ChatBot, FlashcardCreator, FlashcardService, rate_limit

__all__ = ['FlashcardCreator', 'ChatBot', 'FlashcardService', 'rate_limit']

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/main.py`:

```py
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.middleware.sessions import SessionMiddleware

from ..core.config import settings
from .routes import flashcard_routes, health_routes, websocket_routes
from src.core.container import cleanup_dependencies, init_dependencies
from contextlib import asynccontextmanager
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.middleware.sessions import SessionMiddleware
from src.core.config import settings
from .middleware.rate_limiting import RateLimitMiddleware
import uvicorn
from fastapi import FastAPI,  Request
from src.domain.chatbot.factory import ChatBotFactory


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await init_dependencies()
    yield
    # Shutdown
    await cleanup_dependencies()



def create_app() -> FastAPI:
    """
    Create and configure the FastAPI application.

    Returns:
        FastAPI: Configured application instance
    """
    app = FastAPI(
        title="Flashcard Generator API",
        description="API for generating flashcards from Notion pages",
        version="1.0.0",
        lifespan=lifespan,
    )
    app.add_middleware(SessionMiddleware, secret_key=settings.secret_key)
    # Add middleware
    app.add_middleware(RateLimitMiddleware, calls=settings.rate_limit_calls, period=settings.rate_limit_period)

    # Mount static files and templates
    app.mount("/static", StaticFiles(directory="static"), name="static")

    # Include routers
    app.include_router(flashcard_routes.router, prefix="")
    app.include_router(health_routes.router)
    app.include_router(websocket_routes.router)

    return app


app = create_app()
templates = Jinja2Templates(directory="templates")


@app.get("/")
async def home(request: Request):
    """
    Home route rendering the index page.

    Args:
        request (Request): Incoming HTTP request

    Returns:
        TemplateResponse: Rendered index page
    """
    return templates.TemplateResponse(
        "index.html", {"request": request, "chatbot_types": ChatBotFactory.get_available_chatbots()}
    )



if __name__ == "__main__":
    uvicorn.run("api:app", host="0.0.0.0", port=8000, reload=True, ws="websockets", log_level="info")

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/__init__.py`:

```py
from . import flashcard_routes
from . import health_routes
from . import websocket_routes

__all__ = ['flashcard_routes', 'health_routes', 'websocket_routes']
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/flashcard_routes.py`:

```py
import csv
import logging
import os
import uuid
from datetime import datetime
from typing import Optional, Union

from fastapi import BackgroundTasks, Depends, HTTPException, Response

from pydantic import BaseModel, Field, field_validator


from src.core.auth import get_current_user
from src.domain.chatbot.factory import ChatBotFactory
from src.domain.flashcard.service import FlashcardCreator, FlashcardService
from src.domain.notion.factory import create_notion_service
from src.domain.task.service import TaskService
from src.repositories.FlashcardRepository import CSVFlashcardRepository
from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException
from src.core.container import  get_task_service


# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

router = APIRouter()


class FlashcardRequest(BaseModel):
    """Request schema for generating flashcards"""
    notion_page: str
    output_path: str= Field("output/flashcards.csv", description="Path to save the flashcards")
    batch_size: int = Field(10, gt=0, le=100)  # Positive integer, max 100
    use_chatbot: bool = Field(False)
    chatbot_type: Optional[str] = Field(None, strip_whitespace=True)

    class Config:
        schema_extra = {
            "example": {
                "notion_page": "page_id_or_url",
                "output_path": "output/flashcards.csv",
                "batch_size": 10,
                "use_chatbot": True,
                "chatbot_type": "groq"
            }
        }

    @field_validator("chatbot_type")
    def validate_chatbot_type(cls, value, values):
        """
        Validate chatbot type when using a chatbot.

        Args:
            value (str): Chatbot type
            values (Dict): Other request values

        Returns:
            str: Validated chatbot type

        Raises:
            ValueError: If chatbot type is invalid
        """
        if values.data.get('use_chatbot'):
            if not value:
                raise ValueError("Chatbot type is required when use_chatbot is True")
            available_chatbots = ChatBotFactory.get_available_chatbots()
            if value not in available_chatbots:
                raise ValueError(f"Invalid chatbot type. Allowed types: {available_chatbots}")
        return value


class FlashcardResponse(BaseModel):
    """Response schema for generating flashcards"""
    message: str
    task_id: str


async def generate_flashcards_task(task_service: TaskService, user_id: str, task_id: str, request: FlashcardRequest):
    """
    Background task for generating flashcards.

    Args:
        task_id (str): Unique identifier for the task
        request (FlashcardRequest): Flashcard generation request details
    """
    try:
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=0, status="starting", message="Initializing components..."
        )
        # Initialize components
        flashcard_repository = CSVFlashcardRepository(anki_output_file=request.output_path)
        notion_service = await create_notion_service()
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=20, status="processing", message="Fetching Notion content..."
        )
        notion_page = await notion_service.get_page_content(request.notion_page)
        notion_content = notion_page.to_flashcard_format

        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=20, status="processing", message="Creating flashcards..."
        )
        flashcard_creator = FlashcardCreator(
            flashcard_repository=flashcard_repository, task_service=task_service, task_id=task_id, user_id=user_id
        )

        # Prepare service with or without chatbot
        async def run_flashcard_service(chatbot=None) -> Union[str, str]:
            """
            Run flashcard service with optional chatbot.

            Args:
                chatbot (Optional[ChatBot]): Chatbot for summary generation
            """
            service = FlashcardService(
                flashcard_creator=flashcard_creator, notion_content=notion_content, chatbot=chatbot
            )
            return await service.run()

        if request.use_chatbot:
            chatbot = await ChatBotFactory.create(request.chatbot_type)
            async with chatbot:
                result_message, result_status = await run_flashcard_service(chatbot)
        else:
            result_message, result_status = await run_flashcard_service()

        logger.info(f"Task {task_id} completed successfully.")

        # Add to history
        await task_service.add_to_history(
            user_id,
            {
                "task_id": task_id,
                "notion_page": notion_page.url,
                "chatbot_type": request.chatbot_type,
                "output_path": request.output_path,
                "timestamp": datetime.now().isoformat(),
                "status": result_status,
            },
        )

    except Exception as e:
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=0, status="failed", message=str(e)
        )
        logger.exception(f"Task {task_id} failed")
        raise


@router.post("/generate-flashcards/", response_model=FlashcardResponse)
async def create_flashcards(
    request: FlashcardRequest,
    background_tasks: BackgroundTasks,
    current_user: str = Depends(get_current_user),
    task_service: TaskService = Depends(get_task_service),
):
    """
    Endpoint to initiate flashcard generation.

    Args:
        request (FlashcardRequest): Flashcard generation request details
        background_tasks (BackgroundTasks): FastAPI background tasks manager
        current_user (str): user id
        task_service (TaskService): task_service

    Returns:
        FlashcardResponse: Task initiation response
    """
    try:
        # Generate unique task ID and output path
        task_id = f"task_{uuid.uuid4()}"
        output_path = f"output/flashcards_{task_id}.csv"
        request.output_path = output_path
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        # Create task with initial status
        await task_service.create_task(
            user_id=current_user,
            task_id=task_id,
            initial_data={"status": "created", "output_path": output_path, "request": request.model_dump()},
        )

        # Add flashcard generation to background tasks
        background_tasks.add_task(
            generate_flashcards_task, task_service=task_service, user_id=current_user, task_id=task_id, request=request
        )

        return FlashcardResponse(message="Flashcard generation started", task_id=task_id)
    except Exception as e:
        logger.exception("Failed to initiate flashcard generation")
        raise HTTPException(status_code=500, detail="An error occurred while starting the flashcard generation.")


@router.get("/task-status/{task_id}")
async def get_task_status(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Retrieve status of a specific task.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService): task_service

    Returns:
        Dict: Task status information

    Raises:
        HTTPException: If task is not found
    """
    return await task_service.get_task_status(current_user, task_id)


@router.get("/generation-history")
async def get_generation_history(
    current_user: str = Depends(get_current_user),
    limit: int = 50,
    task_service: TaskService = Depends(get_task_service),
):
    """
    Retrieve generation history.

    Returns:
        List[Dict]: List of past generation tasks
    """
    return await task_service.get_user_history(current_user, limit)


@router.get("/preview-flashcards/{task_id}")
async def preview_flashcards(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Preview first 5 generated flashcards.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService): task_service

    Returns:
        List[Dict]: Preview of generated flashcards

    Raises:
        HTTPException: If flashcards are not found or still processing
    """
    task = await task_service.get_task_status(current_user, task_id)
    if not task or task["status"] not in ["completed", "completed_with_errors"]:
        raise HTTPException(status_code=404, detail="Flashcards not found or still processing")
    output_path = f"output/flashcards_{task_id}.csv"
    preview_cards = []
    try:
        with open(output_path, 'r', encoding='utf-8') as f:
            reader = csv.reader(f)
            for i, row in enumerate(reader):
                if i >= 5:  # Preview only first 5 cards
                    break
                preview_cards.append({"front": row[0], "back": row[1]})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    return preview_cards


@router.get("/download/{task_id}")
async def download_flashcards(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Download generated flashcards CSV file.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService) : task_service

    Returns:
        Response: CSV file download

    Raises:
        HTTPException: If flashcards are not found or an error occurs
    """
    task = await task_service.get_task_status(current_user, task_id)
    if not task or task["status"] not in ["completed", "completed_with_errors"]:
        raise HTTPException(status_code=404, detail="Flashcards not found or still processing")
    output_path = f"output/flashcards_{task_id}.csv"
    try:
        with open(output_path, 'rb') as f:
            content = f.read()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    return Response(
        content=content,
        media_type='text/csv',
        headers={'Content-Disposition': f'attachment; filename="flashcards_{task_id}.csv"'},
    )


```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/health_routes.py`:

```py
from fastapi import APIRouter, Request
from monitoring.health import HealthCheck

router = APIRouter()


@router.get("/health")
async def health_check(request: Request):
    """
    Perform system health check.

    Args:
        request (Request): Incoming HTTP request

    Returns:
        Dict: Health check results
    """
    async with HealthCheck() as health_check:
        return await health_check.get_health(request)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/websocket_routes.py`:

```py

from fastapi import APIRouter, WebSocket, Depends
from typing import Optional
import logging

from ...common.websocket import WebSocketManager
from ...core.container import get_websocket_manager
from fastapi import Depends,WebSocket, WebSocketDisconnect

logger = logging.getLogger(__name__)
router = APIRouter()

@router.websocket("/ws/{task_id}")
async def websocket_endpoint(
    websocket: WebSocket, task_id: str, websocket_manager: WebSocketManager = Depends(get_websocket_manager)
):
    """
    WebSocket endpoint for real-time task progress updates.

    Args:
        websocket (WebSocket): WebSocket connection
        task_id (str): Unique identifier for the task
        websocket_manager(WebSocketManager): WebSocket connections manager for task progress tracking
    """
    try:
        await websocket_manager.connect(task_id, websocket)
        while True:
            try:
                await websocket.receive_text()
            except WebSocketDisconnect:
                logger.info(f"WebSocket disconnected for task {task_id}")
                break
            except Exception as e:
                logger.error(f"WebSocket error for task {task_id}: {str(e)}")
                break
    finally:
        websocket_manager.disconnect(task_id)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/middleware/rate_limiting.py`:

```py
import time
from collections import defaultdict

from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware for rate limiting API requests"""

    def __init__(self, app, calls: int, period: int):
        super().__init__(app)
        self.calls = calls
        self.period = period
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next) -> Response:
        """
        Dispatch the request to the next middleware or the endpoint handler.
        Only apply rate limiting to the generate-flashcards endpoint
        """
        if request.url.path == "/generate-flashcards/":
            client_ip = request.headers.get("X-Forwarded-For")
            if client_ip is None:
                # Handle the case where client_ip is None
                client_ip = "127.0.0.1"

            current_time = time.time()

            # Remove outdated requests
            self.requests[client_ip] = [t for t in self.requests[client_ip] if t > current_time - self.period]

            if len(self.requests[client_ip]) >= self.calls:
                return JSONResponse(status_code=429, content={"error": "Rate limit exceeded"})

            self.requests[client_ip].append(current_time)

        response = await call_next(request)
        return response

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/websocket.py`:

```py
import logging
from typing import Dict

from fastapi import WebSocket

logger = logging.getLogger(__name__)


class WebSocketManager:
    """Manages WebSocket connections for task progress tracking."""

    def __init__(self):
        """Initialize WebSocket connections dictionary."""
        self.connections: Dict[str, WebSocket] = {}
        logger.info("WebSocketManager initialized")

    async def connect(self, task_id: str, websocket: WebSocket):
        """
        Establish a WebSocket connection for a specific task.

        Args:
            task_id (str): Unique identifier for the task
            websocket (WebSocket): WebSocket connection
        """
        try:
            await websocket.accept()
            self.connections[task_id] = websocket
            logger.info(f"WebSocket connection established for task {task_id}")
        except Exception as e:
            logger.error(f"Failed to establish WebSocket connection for task {task_id}: {str(e)}")
            raise

    def disconnect(self, task_id: str):
        """
        Remove a WebSocket connection.

        Args:
            task_id (str): Unique identifier for the task
        """
        if task_id in self.connections:
            self.connections.pop(task_id)
            logger.info(f"WebSocket connection removed for task {task_id}")

    async def send_progress(self, task_id: str, progress_data: Dict):
        """
        Send progress update to a specific WebSocket connection.

        Args:
            task_id (str): Unique identifier for the task
            progress_data (Dict): Progress update information
        """
        if task_id in self.connections:
            try:
                websocket = self.connections[task_id]
                await websocket.send_json(progress_data)
                logger.debug(f"Progress update sent for task {task_id}: {progress_data}")
            except Exception as e:
                logger.error(f"Failed to send progress update for task {task_id}: {str(e)}")
                self.disconnect(task_id)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/error_handling.py`:

```py
import logging
from functools import wraps
from typing import Callable, Optional

logging.basicConfig(level=logging.ERROR)


class AppError(Exception):
    """Base application-specific exception"""

    def __init__(self, message: str, context: Optional[dict] = None):
        self.message = message
        self.context = context or {}
        super().__init__(self.message)


class ConfigurationError(AppError):
    """Raised when there's a configuration-related issue"""

    pass


class ExternalServiceError(AppError):
    """Raised when an external service (like Notion) fails"""

    pass


def handle_errors_decorator(
    default_return_value=None, exceptions=(Exception,), message="An error occurred"
) -> Callable:
    """
    Decorator for handling errors in a function.

    Args:
        default_return_value (Any, optional): The default return value if an error occurs. Defaults to None.
        exceptions (tuple, optional): The exceptions to catch. Defaults to (Exception,).
        message (str, optional): The message to log if an error occurs. Defaults to "An error occurred".

    Returns:
        Callable: The decorated function.
    """

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except exceptions as e:
                logging.error(f"{message} in {func.__name__}: {e}")
                return default_return_value

        return wrapper

    return decorator


import logging
from functools import wraps
from typing import Any, Callable, List, Optional, Type


class AppError(Exception):
    """Base application-specific exception"""

    def __init__(self, message: str, context: Optional[dict] = None):
        self.message = message
        self.context = context or {}
        super().__init__(self.message)


class ConfigurationError(AppError):
    """Raised when there's a configuration-related issue"""

    pass


class ExternalServiceError(AppError):
    """Raised when an external service (like Notion) fails"""

    pass


def handle_errors(
    logger: logging.Logger,
    default_return: Any = None,
    exceptions: List[Type[Exception]] = None,
    error_type: Optional[Type[AppError]] = None,
) -> Callable:
    """
    Advanced error handling decorator with more robust logging and error tracking

    Args:
        logger: Logging instance to use
        default_return: Value to return if an error occurs
        exceptions: List of specific exceptions to catch
        error_type: Custom error type to raise
    """
    exceptions = exceptions or [Exception]

    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except tuple(exceptions) as e:
                # Detailed error logging
                error_details = {'function': func.__name__, 'module': func.__module__, 'args': args, 'kwargs': kwargs}

                # Log the error with context
                logger.error(f"Error in {func.__name__}: {str(e)}", extra={'error_details': error_details})

                # Optionally raise a custom error type
                if error_type:
                    raise error_type(message=str(e), context=error_details) from e

                return default_return

        return wrapper

    return decorator

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/errors.py`:

```py
class AppError(Exception):
    """Base application exception"""
    pass

class ValidationError(AppError):
    """Raised when input validation fails"""
    pass

class NotionError(AppError):
    """Raised when Notion API operations fail"""
    pass

class FlashcardError(AppError):
    """Raised when flashcard operations fail"""
    pass

class ChatBotError(AppError):
    """Raised when chatbot operations fail"""
    pass
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/container.py`:

```py
# src/dependencies/container.py
import asyncio
import logging
from typing import Optional

from redis.asyncio import Redis, RedisCluster
from redis.asyncio.cluster import ClusterNode

from src.common.websocket import WebSocketManager
from src.core.config import settings
from src.domain.task.service import TaskService

logger = logging.getLogger(__name__)


class RedisConnection:
    """Singleton Redis connection manager."""

    _instance: Optional[Redis] = None
    _lock: asyncio.Lock = asyncio.Lock()

    @classmethod
    async def get_connection(cls) -> Redis:
        """Get or create Redis connection."""
        async with cls._lock:
            if cls._instance is None:
                try:
                    if settings.environment == "production":
                        nodes = [ClusterNode(host, port) for host, port in settings.redis_cluster_nodes]
                        cls._instance = RedisCluster(
                            startup_nodes=nodes, decode_responses=True, max_connections=settings.redis_max_connections
                        )
                    else:
                        cls._instance = Redis(
                            host=settings.redis_host,
                            port=settings.redis_port,
                            decode_responses=True,
                            max_connections=settings.redis_max_connections,
                        )
                    # Verify connection
                    await cls._instance.ping()
                    logger.info("Redis connection established successfully")
                except Exception as e:
                    logger.error(f"Failed to establish Redis connection: {e}")
                    raise
            return cls._instance

    @classmethod
    async def close(cls):
        """Close Redis connection."""
        if cls._instance:
            await cls._instance.close()
            cls._instance = None
            logger.info("Redis connection closed")


class DependencyContainer:
    """Singleton container for application-wide dependencies."""

    _instance: Optional['DependencyContainer'] = None
    _websocket_manager: Optional[WebSocketManager] = None
    _task_service: Optional[TaskService] = None
    _redis: Optional[Redis] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._websocket_manager = WebSocketManager()
        return cls._instance

    @classmethod
    def get_websocket_manager(cls) -> WebSocketManager:
        """Get or create WebSocketManager instance."""
        if cls._websocket_manager is None:
            cls._websocket_manager = WebSocketManager()
            logger.info("Created new WebSocketManager instance")
        return cls._websocket_manager

    @classmethod
    async def get_task_service(cls) -> TaskService:
        """Get or create TaskService instance with shared WebSocketManager."""
        if cls._task_service is None:
            websocket_manager = cls.get_websocket_manager()
            redis = await RedisConnection.get_connection()
            cls._task_service = TaskService(redis=redis, websocket_manager=websocket_manager)
            logger.info("Created new TaskService instance")
        return cls._task_service


# FastAPI dependencies
async def get_redis() -> Redis:
    """Dependency for getting Redis connection."""
    return await RedisConnection.get_connection()


async def get_websocket_manager() -> WebSocketManager:
    """Dependency for getting WebSocketManager instance."""
    return DependencyContainer.get_websocket_manager()


async def get_task_service() -> TaskService:
    """Dependency for getting TaskService instance."""
    return await DependencyContainer.get_task_service()


# Application lifecycle management
async def init_dependencies():
    """Initialize application dependencies."""
    try:
        logger.info("Initializing application dependencies...")
        await RedisConnection.get_connection()
        await DependencyContainer.get_task_service()
        logger.info("Dependencies initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize dependencies: {e}")
        raise


async def cleanup_dependencies():
    """Cleanup application dependencies."""
    try:
        logger.info("Cleaning up application dependencies...")
        await RedisConnection.close()
        logger.info("Dependencies cleaned up successfully")
    except Exception as e:
        logger.error(f"Error during dependency cleanup: {e}")
        raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/auth.py`:

```py
import uuid

from fastapi import Request


async def get_current_user(request: Request) -> str:

    user_id = request.session.get("user_id")
    if not user_id:
        user_id = str(uuid.uuid4())
        request.session["user_id"] = user_id
    return user_id

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/config.py`:

```py
import secrets
from typing import List, Tuple

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    notion_api_key: str = Field(..., env="NOTION_API_KEY", description="API Key for Notion service")
    groq_api_key: str = Field(..., env="GROQ_API_KEY", description="API Key for Groq chatbot service")
    mistral_api_key: str = Field(..., env="MISTRAL_API_KEY", description="API Key for Mistral chatbot service")
    max_retries: int = Field(3, description="Maximum number of retries for API calls")
    rate_limit_calls: int = Field(5, description="Rate limit - maximum calls allowed in the specified period")
    rate_limit_period: int = Field(60, description="Rate limit time period in seconds")
    cache_expiry: int = Field(3600, description="Cache expiry duration in seconds")
    cache_maxsize: int = Field(100, description="Cache maximum size")
    environment: str = Field("development", description="Environment for task tracking")
    secret_key: str = Field(secrets.token_urlsafe(32), description="Secret key for session management")
    redis_cluster_nodes: List[Tuple[str, int]] = Field(
        [("localhost", 7001), ("localhost", 7002), ("localhost", 7003)], description="Redis cluster node IP addresses"
    )
    redis_host: str = Field("localhost", description="Redis host")
    redis_port: int = Field(6379, description="Redis port")
    redis_max_connections: int = Field(10, description="Redis max connections")

    @field_validator('notion_api_key', 'groq_api_key', 'mistral_api_key')
    def validate_api_keys(cls, v: str) -> str:
        """
        Validate that API keys are not empty and meet basic length criteria.
        """
        if not v or len(v.strip()) < 10:
            raise ValueError("The API key appears to be invalid or too short.")
        return v

    class Config:
        # Automatically load the settings from environment variables
        env_file = ".env"
        env_file_encoding = "utf-8"


# Create a settings instance
settings = Settings()

# Export settings instance
__all__ = ['settings']

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/repositories/FlashcardRepository.py`:

```py
import csv
import logging
import os
from abc import ABC, abstractmethod
from typing import Generic, TypeVar

import aiofiles

from src.domain.flashcard.models import Flashcard

# Generic type for repository
T = TypeVar('T')


class FlashcardRepositoryInterface(ABC, Generic[T]):
    """Abstract base class defining the interface for Flashcard repositories."""

    @abstractmethod
    async def get_existing_flashcards(self) -> set:
        """
        Retrieve a set of existing flashcards.

        Returns:
            set: A set of existing flashcard identifiers.
        """
        pass

    @abstractmethod
    async def save_flashcard(self, item: T) -> None:
        """
        Save a single flashcard.

        Args:
            item (T): The flashcard to be saved.
        """
        pass


class CSVFlashcardRepository(FlashcardRepositoryInterface):
    """Concrete implementation of a CSV-based Flashcard repository."""

    def __init__(self, anki_output_file: str):
        """
        Initialize the CSV Flashcard Repository.

        Args:
            anki_output_file (str): Path to the output CSV file.
        """
        self.anki_output_file = anki_output_file
        self.logger = logging.getLogger(__name__)

    async def get_existing_flashcards(self) -> set:
        """
        Load existing flashcards from the CSV file.

        Returns:
            set: A set of existing flashcard front texts.
        """
        existing_flashcards = set()

        if not os.path.exists(self.anki_output_file):
            return existing_flashcards

        try:
            async with aiofiles.open(self.anki_output_file, mode="r", encoding="utf-8") as file:
                content = await file.read()
                reader = csv.reader(content.splitlines())
                existing_flashcards = {row[0] for row in reader if row}

            self.logger.info(f"Loaded {len(existing_flashcards)} existing flashcards")
        except Exception as e:
            self.logger.error(f"Error loading existing flashcards: {str(e)}")

        return existing_flashcards

    async def save_flashcard(self, item: Flashcard) -> None:
        """
        Save a single flashcard to the CSV file.

        Args:
            item (Flashcard): The flashcard to be saved.

        Raises:
            Exception: If there's an error during file writing.
        """
        try:
            async with aiofiles.open(self.anki_output_file, mode="a", encoding="utf-8", newline="") as file:
                writer = csv.writer(file)
                await writer.writerow([item.front, item.back])
                self.logger.info(f"Flashcard with front: '{item.front[:50]}...' created!")
        except Exception as e:
            self.logger.error(f"Error saving flashcard: {str(e)}")
            raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/api.txt`:

```txt
fastapi>=0.115.5
uvicorn[standard]>=0.32.1
starlette>=0.41.3
python-multipart>=0.0.6
jinja2>=3.1.2
aiofiles==23.2.1

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/test.txt`:

```txt
pytest==8.3.3
pytest-cov==6.0.0
pytest-mock==3.14.0
pytest-asyncio==0.24.0
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/dev.txt`:

```txt
isort
black
pre-commit
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/base.txt`:

```txt
notion-client==2.2.1
mistralai==1.2.3
groq==0.12.0
pydantic==2.9.2
cachetools==5.5.0
tenacity==9.0.0
pydantic_settings==2.6.1
wsproto==1.2.0
redis==5.2.0
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/tests/test_flashcard.py`:

```py
import unittest
from unittest.mock import Mock, patch

import pytest
from fastapi import HTTPException
from fastapi.testclient import TestClient

from src.api.routes.flashcard_routes import FlashcardRequest, FlashcardResponse, app, generate_flashcards_task, update_task_progress

unittest.TestCase

client = TestClient(app)


@pytest.fixture
def mock_notion_content():
    return Mock()


@pytest.fixture
def mock_chatbot():
    chatbot = Mock(spec=["get_summary"])
    chatbot.get_summary.return_value = "This is a test summary"
    return chatbot


@pytest.fixture
def mock_repository():
    repository = Mock(spec=["save_flashcard", "get_existing_flashcards"])
    repository.save_flashcard.return_value = None
    return repository


class TestFlashcardCreator:

    async def test_validate_flashcard_content(self, mock_repository):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)

        # Test valid cases
        assert creator.validate_flashcard_content("Valid content") == True
        assert creator.validate_flashcard_content("ABC") == True

        # Test invalid cases
        assert creator.validate_flashcard_content("") == False
        assert creator.validate_flashcard_content("ab") == False
        assert creator.validate_flashcard_content("a" * 501) == False
        assert creator.validate_flashcard_content(None) == False
        assert creator.validate_flashcard_content(123) == False

    @unittest.skip("Skipping test_get_cached_summary")
    async def test_get_cached_summary(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)

        # Test first call (cache miss)
        result1 = await creator.get_cached_summary("test prompt", mock_chatbot)
        assert result1 == "This is a test summary"
        mock_chatbot.get_summary.assert_called_once()

        # Test second call (cache hit)
        mock_chatbot.get_summary.reset_mock()
        result2 = await creator.get_cached_summary("test prompt", mock_chatbot)
        assert result2 == "This is a test summary"
        mock_chatbot.get_summary.assert_not_called()

    @pytest.mark.parametrize(
        "test_input,expected",
        [
            ([], 0),  # Empty list
            ([{"text": "test", "url": "http://test.com"}], 1),  # Single item
            ([{"text": "test1", "url": "url1"}, {"text": "test2", "url": "url2"}], 2),  # Multiple items
        ],
    )
    @unittest.skip("Skipping test_create_flashcards")
    async def test_create_flashcards(self, test_input, expected, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)
        await creator.create_flashcards(test_input, mock_chatbot)
        assert mock_repository.save_flashcard.call_count == expected

    @unittest.skip("Skipping test_create_flashcards_with_existing_cards")
    async def test_create_flashcards_with_existing_cards(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        mock_repository.get_existing_flashcards.return_value = {"test1"}
        creator = FlashcardCreator(mock_repository)

        input_data = [
            {"front": "test1", "back": "url1"},  # Should be skipped
            {"front": "test2", "back": "url2"},  # Should be processed
        ]

        await creator.create_flashcards(input_data, mock_chatbot)
        assert mock_repository.save_flashcard.call_count == 1

    async def test_error_handling(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)
        mock_chatbot.get_summary.side_effect = Exception("API Error")

        with pytest.raises(Exception):
            await creator.get_cached_summary("test prompt", mock_chatbot)


class TestFlashcardService(unittest.TestCase):

    async def test_service_initialization(self, mock_notion_content, mock_chatbot, mock_repository):
        from src.domain.flashcard.service import FlashcardCreator, FlashcardService

        creator = FlashcardCreator(mock_repository)
        service = FlashcardService(notion_content=mock_notion_content, chatbot=mock_chatbot, flashcard_creator=creator)
        assert service.notion_content == mock_notion_content
        assert service.chatbot == mock_chatbot
        assert service.flashcard_creator == creator

    async def test_service_run(self):
        with patch('src.flashcard.notion_content') as mock_notion_content:
            with patch('src.flashcard.chatbot') as mock_chatbot:
                with patch('src.flashcard.repository') as mock_repository:
                    from src.domain.flashcard.service import FlashcardCreator, FlashcardService

                    creator = FlashcardCreator(mock_repository)
                    service = FlashcardService(
                        notion_content=mock_notion_content, chatbot=mock_chatbot, flashcard_creator=creator
                    )
                    await service.run()
                    assert mock_repository.save_flashcard.call_count == 2


class TestAPI(unittest.TestCase):
    async def test_create_flashcards_endpoint(self):
        response = client.post(
            "/generate-flashcards/",
            json={"notion_page_id": "test-page", "use_chatbot": False, "output_path": "test.csv"},
        )
        assert response.status_code == 200
        assert "task_id" in response.json()

    async def test_create_flashcards_with_chatbot(self):
        response = client.post(
            "/generate-flashcards/",
            json={
                "notion_page_id": "test-page",
                "use_chatbot": True,
                "chatbot_type": "groq",
                "output_path": "test.csv",
            },
        )
        assert response.status_code == 200
        assert "task_id" in response.json()

    async def test_create_flashcards_invalid_chatbot_type(self):
        response = client.post(
            "/generate-flashcards/",
            json={
                "notion_page_id": "test-page",
                "use_chatbot": True,
                "chatbot_type": "invalid_type",
                "output_path": "test.csv",
            },
        )
        assert response.status_code == 422

    async def test_get_task_status(self):
        # Mock the client.get method
        client.get = Mock(return_value=Mock(status_code=404))

        # Make a GET request to /task-status/{task_id}
        task_id = "some_task_id"
        response = client.get(f"/task-status/{task_id}")

        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)

```
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/docker/docker-compose.yml`:

```yml
version: '3.8'
services:
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
    command: redis-server
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/docker/docker-compose.prod.yml`:

```yml
version: '3.8'
services:
  redis-node1:
    image: bitnami/redis-cluster:latest
    environment:
      - REDIS_NODES=3
    ports:
      - "7001:7001"

  redis-node2:
    image: bitnami/redis-cluster:latest
    ports:
      - "7002:7002"

  redis-node3:
    image: bitnami/redis-cluster:latest
    ports:
      - "7003:7003"
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/Makefile`:

```
.PHONY: test test-cov test-html clean

test:
	pytest -v

test-cov:
	pytest --cov=. --cov-report=term-missing

test-html:
	pytest --cov=. --cov-report=html

clean:
	rm -rf .coverage htmlcov .pytest_cache __pycache__

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/setup.py`:

```py
from setuptools import find_packages, setup

setup(
    name="notion2anki",
    version="0.1",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/README.md`:

```md
Create Anki flashcards from the Notion content!

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/pyproject.toml`:

```toml
[tool.black]
line-length = 120
target-version = ["py312"]
skip-string-normalization = true

[tool.isort]
profile = "black"
line_length = 120
sections = ["FUTURE", "STDLIB", "THIRDPARTY", "FIRSTPARTY", "LOCALFOLDER"]

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/templates/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="min-h-screen p-8">
        <div class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Generator Form -->
            <div class="bg-white p-8 rounded-lg shadow-md h-full">
                <h1 class="text-2xl font-bold mb-6 text-center">Flashcard Generator</h1>
                
                <form id="flashcardForm" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Notion Page URL or ID</label>
                        <input type="text" id="notionPage" required
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700">
                            <input type="checkbox" id="useChatbot" class="mr-2">
                            Use chatbot to summarize answer
                        </label>
                    </div>
                    
                    <div id="chatbotTypeContainer" class="hidden">
                        <label class="block text-sm font-medium text-gray-700">Chatbot Type</label>
                        <select id="chatbotType" disabled
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                            {% for type in chatbot_types %}
                                <option value="{{ type }}">{{ type|title }}</option>
                            {% endfor %}
                        </select>
                    </div>                

                    <button type="submit"
                            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Generate Flashcards
                    </button>
                </form>

                <!-- Progress Section -->
                <div id="progress-section" class="mt-6 hidden">
                    <h2 class="text-lg font-semibold mb-2">Generation Progress</h2>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <p id="progress-status" class="mt-2 text-sm text-gray-600"></p>
                </div>

                <!-- Status and Result -->
                <div id="status" class="mt-4 hidden">
                    <div class="flex items-center justify-center">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                        <span class="ml-2">Generating flashcards...</span>
                    </div>
                </div>

                <div id="result" class="mt-4 hidden">
                    <div class="p-4 rounded-md">
                        <p class="text-sm"></p>
                    </div>
                </div>

                <!-- Download Button -->
                <div id="download-section" class="mt-4 hidden">
                    <button id="download-btn" class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700">
                        Download Flashcards
                    </button>
                </div>
            </div>

            <!-- Preview and History Section -->
            <div class="space-y-8">
                <!-- Preview Section -->
                <div id="preview-section" class="bg-white p-8 rounded-lg shadow-md hidden">
                    <h2 class="text-xl font-bold mb-4">Preview</h2>
                    <div id="preview-cards" class="space-y-4">
                        <!-- Preview cards will be inserted here -->
                    </div>
                </div>

                <!-- History Section -->
                <div class="bg-white p-8 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold mb-4">Generation History</h2>
                    <div id="history-list" class="space-y-4">
                        <!-- History items will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/static/js/flashcard_generator.js"></script>
    
</body>
</html>
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/monitoring/health.py`:

```py
# monitoring/health.py
from dataclasses import dataclass
from typing import Any, Dict, Optional

import httpx
from fastapi import HTTPException, Request, Response
from fastapi.responses import JSONResponse

from src.core.config import settings
from src.domain.chatbot.factory import ChatBotFactory


@dataclass
class ServiceHealth:
    notion_api: bool
    chatbots: Dict[str, bool]


class HealthCheck:
    """Health check service for APIs"""

    def __init__(self):
        self.client = httpx.AsyncClient()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.client.aclose()

    async def _check_notion_api(self) -> bool:
        """Check the health of the Notion API."""
        try:
            response = await self.client.get(
                "https://api.notion.com/v1/users/me",
                headers={"Authorization": f"Bearer {settings.notion_api_key}", "Notion-Version": "2022-06-28"},
            )
            return response.status_code == 200
        except Exception:
            return False

    async def _check_chatbots(self) -> Dict[str, bool]:
        """Check the health of all available chatbots."""
        chatbot_health = {}
        for chatbot_type in ChatBotFactory.get_available_chatbots():
            try:
                chatbot = await ChatBotFactory.create(chatbot_type)
                summary = await chatbot.get_summary("Just say hi!")
                chatbot_health[chatbot_type] = summary is not None
                await chatbot.cleanup()
            except Exception:
                chatbot_health[chatbot_type] = False
        return chatbot_health

    async def check_services(self) -> Dict[str, Any]:
        """Perform health checks for all services."""
        health_status = {
            "notion_api": await self._check_notion_api(),
            "chatbots": await self._check_chatbots(),
        }
        return ServiceHealth(**health_status).__dict__

    async def get_health(self, request: Request):
        """Endpoint to return the health status of all services."""
        health_check = await self.check_services()
        status = "healthy" if all(health_check.values()) else "unhealthy"
        return JSONResponse(
            content={"status": status, "services": health_check}, status_code=200 if status == "healthy" else 503
        )

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/task/service.py`:

```py
# src/services/task_service.py
import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional

from fastapi import HTTPException
from redis.asyncio import Redis

from src.common.websocket import WebSocketManager

logger = logging.getLogger(__name__)


class TaskService:
    def __init__(self, redis: Redis, websocket_manager: WebSocketManager):
        self.redis = redis
        self.websocket_manager = websocket_manager
        self._lock = asyncio.Lock()  # Add lock for Redis operations

    async def create_task(self, user_id: str, task_id: str, initial_data: Dict) -> None:
        """Create a new task with initial data."""
        task_key = f"task:{user_id}:{task_id}"
        task_data = {**initial_data, "timestamp": datetime.now().isoformat(), "user_id": user_id}

        try:
            async with self._lock:  # Use lock for Redis operations
                # Store task data with 24-hour TTL
                await self.redis.setex(task_key, 86400, json.dumps(task_data))  # 24 hours
        except Exception as e:
            logger.error(f"Failed to create task {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to create task")

    async def update_task_progress(self, user_id: str, task_id: str, progress: int, status: str, message: str) -> None:
        """Update task progress and notify via WebSocket."""
        task_key = f"task:{user_id}:{task_id}"

        try:
            async with self._lock:  # Use lock for Redis operations
                # Get existing task data
                existing_data = await self.redis.get(task_key)
                if existing_data:
                    task_data = json.loads(existing_data)
                else:
                    task_data = {}

                # Update task data
                task_data.update(
                    {
                        "progress": progress,
                        "status": status,
                        "message": message,
                        "timestamp": datetime.now().isoformat(),
                        "user_id": user_id,
                    }
                )

                # Store updated data
                await self.redis.setex(task_key, 86400, json.dumps(task_data))  # 24 hours

            # Send WebSocket update outside the lock
            try:
                await self.websocket_manager.send_progress(task_id, task_data)
            except Exception as ws_error:
                logger.error(f"WebSocket error for task {task_id}: {ws_error}")

        except Exception as e:
            logger.error(f"Failed to update task {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to update task status")

    async def get_task_status(self, user_id: str, task_id: str) -> Dict:
        """Get current task status."""
        task_key = f"task:{user_id}:{task_id}"

        try:
            task_data = await self.redis.get(task_key)
            if not task_data:
                raise HTTPException(status_code=404, detail="Task not found")

            return json.loads(task_data)

        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to get task status for {task_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to get task status")

    async def add_to_history(self, user_id: str, task_details: Dict) -> None:
        """Add completed task to user's history."""
        history_key = f"history:{user_id}"

        try:
            # Add to sorted set with timestamp as score
            timestamp = datetime.fromisoformat(task_details['timestamp']).timestamp()

            await self.redis.zadd(history_key, {json.dumps(task_details): timestamp})

            # Trim history to last 100 entries
            await self.redis.zremrangebyrank(history_key, 0, -101)

            # Set 30-day TTL for history
            await self.redis.expire(history_key, 2592000)

        except Exception as e:
            logger.error(f"Failed to add task to history for user {user_id}: {e}")
            # Non-critical operation, log error but don't raise exception

    async def get_user_history(self, user_id: str, limit: int = 50) -> List[Dict]:
        """Get user's task history."""
        history_key = f"history:{user_id}"

        try:
            # Get history entries sorted by timestamp
            entries = await self.redis.zrevrange(history_key, 0, limit - 1)

            return [json.loads(entry) for entry in entries]

        except Exception as e:
            logger.error(f"Failed to get history for user {user_id}: {e}")
            raise HTTPException(status_code=500, detail="Failed to retrieve task history")

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/flashcard/models.py`:

```py
from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class Flashcard:
    """Domain model representing a Flashcard."""

    front: str
    back: str
    url: Optional[str] = None
    tags: Optional[List[str]] = field(default_factory=list)
    created_at: Optional[str] = None

    def __post_init__(self):
        """Validate flashcard data after initialization."""
        if not self.front or not self.back:
            raise ValueError("Flashcard must have both front and back content")

        # Trim excessive whitespace
        self.front = self.front.strip()
        self.back = self.back.strip()

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/flashcard/service.py`:

```py
import asyncio
import logging
import time
from functools import wraps
from typing import Callable, Dict, List, Optional, Union

from cachetools import TTLCache
from tenacity import retry, stop_after_attempt, wait_exponential

from src.core.config import settings
from src.core.error_handling import handle_exceptions
from src.core.exceptions.base import FlashcardError, ValidationError
from src.domain.task.service import TaskService

from ...repositories.FlashcardRepository import Flashcard, FlashcardRepositoryInterface
from ..chatbot.base import ChatBot


class FlashcardValidator:
    """Validates flashcard content integrity."""

    @staticmethod
    def validate_flashcard_content(text: str, min_length: int = 3, max_length: int = 500) -> bool:
        """
        Validate flashcard content.

        Args:
            text (str): Text to validate
            min_length (int, optional): Minimum text length. Defaults to 3.
            max_length (int, optional): Maximum text length. Defaults to 500.

        Returns:
            bool: Whether the text meets validation criteria
        """
        if not text or not isinstance(text, str):
            return False

        text = text.strip()
        if not text or text == "Summary unavailable":
            return False

        return min_length <= len(text) <= max_length and text.strip() != "None"


class FlashcardCache:
    """Manage time-limited caching for flashcard summaries."""

    def __init__(self, maxsize: int = 100, ttl: int = 3600):
        """
        Initialize the cache.

        Args:
            maxsize (int, optional): Maximum cache size. Defaults to 100.
            ttl (int, optional): Time-to-live in seconds. Defaults to 3600.
        """
        self.cache = TTLCache(maxsize=maxsize, ttl=ttl)

    def get(self, key: str) -> Optional[str]:
        """
        Retrieve value from cache.

        Args:
            key (str): Cache key

        Returns:
            Optional[str]: Cached value or None
        """
        return self.cache.get(key)

    def set(self, key: str, value: str) -> None:
        """
        Set value in cache.

        Args:
            key (str): Cache key
            value (str): Value to cache
        """
        self.cache[key] = value


def rate_limit(calls: int, period: int):
    """
    Decorator to rate limit async function calls.

    Args:
        calls (int): Maximum number of calls
        period (int): Time period in seconds

    Returns:
        Callable: Decorated function
    """
    min_interval = period / calls
    last_called = [0.0]

    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            if elapsed < min_interval:
                await asyncio.sleep(min_interval - elapsed)
            last_called[0] = time.time()
            return await func(*args, **kwargs)

        return wrapper

    return decorator


class FlashcardCreator:
    """
    Manages the creation of flashcards from various content sources.
    """

    PROMPT_PREFIX = (
        "Summarize the following text for the back of an Anki flashcard. "
        "Provide only the summary, enclosed in [[ ]]: \n"
    )

    def __init__(
        self,
        flashcard_repository: FlashcardRepositoryInterface,
        cache: Optional[FlashcardCache] = None,
        task_service: Optional[TaskService] = None,
        task_id: str = None,
        user_id: str = None,
    ):
        """
        Initialize FlashcardCreator.

        Args:
            flashcard_repository (FlashcardRepositoryInterface): Repository to save flashcards
            cache (Optional[FlashcardCache], optional): Cache for summaries. Defaults to None.
        """
        self.flashcard_repository = flashcard_repository
        self.cache = cache or FlashcardCache(maxsize=settings.cache_maxsize, ttl=settings.cache_expiry)
        self.progress_callback: Optional[Callable] = None
        self.task_service = task_service
        self.logger = logging.getLogger(__name__)
        self.task_id = task_id
        self.user_id = user_id

    @retry(stop=stop_after_attempt(settings.max_retries), wait=wait_exponential(multiplier=1, min=4, max=10))
    @rate_limit(calls=settings.rate_limit_calls, period=settings.rate_limit_period)
    async def get_cached_summary(self, text: str, chatbot: Optional[ChatBot] = None) -> str:
        """
        Generate or retrieve a cached summary for given text.

        Args:
            text (str): Text to summarize
            chatbot (Optional[ChatBot], optional): Chatbot for generating summary

        Returns:
            str: Generated or cached summary
        """
        prompt = f"{self.PROMPT_PREFIX} {text}"
        cache_key = f"summary_{hash(prompt)}"

        # Check cache first
        cached_summary = self.cache.get(cache_key)
        if cached_summary:
            self.logger.info(f"Cache hit for prompt: {text[:50]}...")
            return cached_summary

        # Generate summary if chatbot available
        if not chatbot:
            return text

        try:
            summary = await chatbot.get_summary(prompt)

            if summary:
                self.cache.set(cache_key, summary)
                return summary
            return None
        except Exception as e:
            self.logger.error(f"Error getting summary: {e}")
            return None

    @handle_exceptions({
        ValidationError: (400, "Invalid flashcard data"),
        FlashcardError: (500, "Error processing flashcard")
    })
    async def create_flashcards(
        self, notion_content: List[Dict[str, str]], chatbot: Optional[ChatBot] = None, batch_size: int = 10
    ) -> Union[str, str]:
        """
        Create flashcards from provided content.

        Args:
            headings_and_bullets (List[Dict[str, str]]): Content to convert to flashcards
            chatbot (Optional[ChatBot], optional): Chatbot for summary generation
            batch_size (int, optional): Number of flashcards to process in batch
        """
        self.logger.info(f"Starting flashcard creation for {len(notion_content)} items")

        # Retrieve existing flashcards to avoid duplicates
        existing_flashcards = await self.flashcard_repository.get_existing_flashcards()
        total_items = len(notion_content)
        processed_items = 0
        skipped_items = 0

        for item in notion_content:
            processed_items += 1

            # Create flashcard
            card = Flashcard(front=item["front"], back=item["back"], url=item["url"])

            # Skip existing flashcards
            if card.front in existing_flashcards:
                skipped_items += 1
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="processing",
                        message=f"Skipped existing flashcard ({processed_items}/{total_items})",
                    )
                self.logger.info(f"Skipping existing flashcard: {card.front[:50]}...")
                await asyncio.sleep(0.1)
                continue

            # Validate content
            if not FlashcardValidator.validate_flashcard_content(card.front):
                skipped_items += 1
                self.logger.warning(f"Invalid content skipped: {card.front[:50]}...")
                continue

            try:
                if chatbot:
                    # Try to get summary, skip if it fails
                    summary = await self.get_cached_summary(card.back, chatbot)
                    if summary is None:
                        skipped_items += 1
                        if self.task_service:
                            await self.task_service.update_task_progress(
                                user_id=self.user_id,
                                task_id=self.task_id,
                                progress=int((processed_items / total_items) * 100),
                                status="warning",
                                message=f"Skipped flashcard due to summarization failure ({skipped_items} skipped)",
                            )
                        self.logger.warning(f"Skipping flashcard due to summarization failure: {card.front[:50]}...")
                        continue

                    card.back = summary

                # Append URL to back content
                card.back += f'\n URL: <a href="{item["url"]}">Link</a>'

                # Save flashcard
                await self.flashcard_repository.save_flashcard(card)

                # Update progress after saving
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="processing",
                        message=f"Created flashcard ({processed_items}/{total_items})",
                    )

                self.logger.info(f"Created flashcard: {card.front[:50]}...")
                await asyncio.sleep(0.1)

            except Exception as e:
                skipped_items += 1
                self.logger.error(f"Error processing flashcard: {str(e)}")
                if self.task_service:
                    await self.task_service.update_task_progress(
                        user_id=self.user_id,
                        task_id=self.task_id,
                        progress=int((processed_items / total_items) * 100),
                        status="warning",
                        message=f"Error with flashcard ({processed_items}/{total_items}): {str(e)}",
                    )
                await asyncio.sleep(0.1)

        # Final progress update
        if self.task_service:
            if skipped_items == total_items:
                message = "All flashcards failed to generate"
                status = "failed"
            elif skipped_items > 0:
                message = f"Flashcard generation completed with {processed_items - skipped_items} successful and {skipped_items} failed"
                status = "completed_with_errors"
            else:
                message = f"Flashcard generation completed successfully for all {total_items} flashcards"
                status = "completed"

            await self.task_service.update_task_progress(
                user_id=self.user_id,
                task_id=self.task_id,
                progress=100,
                status=status,
                message=message,
            )
        self.logger.info(f"Flashcard creation completed in '{self.flashcard_repository.anki_output_file}'")

        return message, status


class FlashcardService:
    """Orchestrates the flashcard creation process."""

    def __init__(
        self,
        flashcard_creator: FlashcardCreator,
        notion_content: List[Dict[str, str]],
        chatbot: Optional[ChatBot] = None,
    ):
        """
        Initialize FlashcardService.

        Args:
            flashcard_creator (FlashcardCreator): Creator to generate flashcards
            notion_content (List[Dict[str, str]]): Content to convert to flashcards
            chatbot (Optional[ChatBot], optional): Chatbot for summary generation
        """
        self.flashcard_creator = flashcard_creator
        self.notion_content = notion_content
        self.chatbot = chatbot
        self.logger = logging.getLogger(__name__)

    async def run(self) -> Union[str, str]:
        """Execute flashcard creation process."""
        try:
            return await self.flashcard_creator.create_flashcards(self.notion_content, self.chatbot)
        except Exception as e:
            self.logger.error(f"Error in flashcard creation: {e}")
            raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/models.py`:

```py
from dataclasses import dataclass
from enum import Enum, auto
from typing import Dict, List, Optional


class BlockType(Enum):
    """Enumeration of supported Notion block types."""

    HEADING_1 = auto()
    HEADING_2 = auto()
    HEADING_3 = auto()
    BULLETED_LIST_ITEM = auto()
    PARAGRAPH = auto()

    @classmethod
    def is_heading(cls, block_type: 'BlockType') -> bool:
        """Check if the block type is a heading."""
        return block_type in {cls.HEADING_1, cls.HEADING_2, cls.HEADING_3}


@dataclass
class NotionBlock:
    """Domain model representing a Notion block with structured information."""

    type: BlockType
    text: str
    url: str
    nested_text: Optional[str] = None

    @property
    def is_heading(self) -> bool:
        """Check if the block is a heading."""
        return BlockType.is_heading(self.type)

    @property
    def to_flashcard_dict(self) -> Dict[str, str]:
        """Convert block to flashcard dictionary format."""
        return {"front": self.text, "back": self.nested_text or self.text, "url": self.url}

    @classmethod
    def from_block_data(cls, block: Dict, base_url: str, nested_text: Optional[str] = None) -> Optional['NotionBlock']:
        """
        Factory method to create NotionBlock from Notion API block data.

        Args:
            block (Dict): Raw block data from Notion API
            base_url (str): Base URL of the Notion page
            nested_text (Optional[str]): Nested content text

        Returns:
            Optional[NotionBlock]: Parsed Notion block or None if unsupported
        """
        block_type = block['type']
        block_id = block['id'].replace("-", "")

        try:
            if block_type in ['heading_1', 'heading_2', 'heading_3']:
                return cls(
                    type=BlockType[block_type.upper().replace('heading_', 'HEADING_')],
                    text=block[block_type]['text'][0]['text']['content'],
                    url=f"{base_url}#{block_id}",
                )
            elif block_type == 'bulleted_list_item':
                return cls(
                    type=BlockType.BULLETED_LIST_ITEM,
                    text=block['bulleted_list_item']['rich_text'][0]['text']['content'],
                    url=f"{base_url}#{block_id}",
                    nested_text=nested_text,
                )
            return None

        except (KeyError, IndexError) as e:
            return None


@dataclass
class NotionPage:
    """Domain model representing a Notion page."""

    id: str
    url: Optional[str]
    blocks: List[NotionBlock]

    @property
    def to_flashcard_format(self) -> List[Dict[str, str]]:
        """Convert page blocks to flashcard format."""
        return [
            block.to_flashcard_dict
            for block in self.blocks
            if block
            and block.type
            in {BlockType.HEADING_1, BlockType.HEADING_2, BlockType.HEADING_3, BlockType.BULLETED_LIST_ITEM}
        ]

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/factory.py`:

```py
from typing import Optional

from src.core.config import settings

from .service import NotionService


async def create_notion_service(api_key: Optional[str] = None) -> NotionService:
    """
    Factory function to create a NotionService instance.

    Args:
        api_key (Optional[str]): Optional API key override

    Returns:
        NotionService: Configured Notion service
    """
    service = NotionService(api_key or settings.notion_api_key)
    return service

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/exceptions.py`:

```py
class NotionServiceError(Exception):
    """Base exception for Notion service-related errors."""

    def __init__(self, message: str):
        self.message = message
        super().__init__(self.message)


class NotionAuthenticationError(NotionServiceError):
    """Raised when there are authentication issues with Notion API."""

    pass


class NotionPageNotFoundError(NotionServiceError):
    """Raised when a Notion page cannot be found."""

    pass


class NotionContentError(NotionServiceError):
    """Raised when there are issues processing Notion content."""

    pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/notion/service.py`:

```py
import re
import logging
from typing import List, Optional, Dict
import asyncio
from notion_client import AsyncClient
from notion_client.errors import APIResponseError, HTTPResponseError

from src.core.config import settings
from src.core.error_handling import handle_exceptions, handle_service_errors
from src.core.exceptions.base import ValidationError, ResourceNotFoundError, ExternalServiceError
from src.core.exceptions.domain import NotionError, NotionAuthenticationError, NotionContentError
from .models import NotionBlock, NotionPage

logger = logging.getLogger(__name__)


class NotionService:
    """Service class for interacting with Notion API."""

    def __init__(self, api_key: Optional[str] = None):
        """Initialize NotionService with API key."""
        try:
            self.client = AsyncClient(auth=api_key or settings.notion_api_key)
            self._url_cache: Dict[str, str] = {}
        except Exception as e:
            raise NotionAuthenticationError() from e

    @staticmethod
    def extract_page_id(page_id_or_url: str) -> str:
        """
        Extract the page ID from a Notion page URL or return the input if it's already a page ID.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            str: Extracted page ID

        Raises:
            ValidationError: If the input is invalid
        """
        if not page_id_or_url:
            raise ValidationError("Page ID or URL cannot be empty", "page_id_or_url")

        if page_id_or_url.startswith(("https://www.notion.so/", "https://notion.so/")):
            match = re.search(r"[a-f0-9]{32}", page_id_or_url)
            if match:
                return match.group()
            raise ValidationError("Invalid Notion URL format", "page_id_or_url")
        
        if not re.match(r"^[a-f0-9]{32}$", page_id_or_url):
            raise ValidationError("Invalid page ID format", "page_id_or_url")
            
        return page_id_or_url

    @handle_service_errors(default_return_value=None)
    async def get_page_url(self, page_id: str) -> Optional[str]:
        """
        Retrieve the URL of the Notion page.

        Args:
            page_id (str): Notion page ID

        Returns:
            Optional[str]: The URL of the page or None if retrieval fails

        Raises:
            NotionError: If there's an error communicating with Notion API
        """
        if page_id in self._url_cache:
            return self._url_cache[page_id]

        try:
            page_content = await self.client.pages.retrieve(page_id=page_id)
            url = page_content.get("url")
            if url:
                self._url_cache[page_id] = url
                return url
            raise NotionError("Page URL not found in response", {"page_id": page_id})
        except APIResponseError as e:
            raise ExternalServiceError("Notion", "Failed to retrieve page URL", {"error": str(e)})

    async def _process_block(self, block: Dict, base_url: str) -> Optional[NotionBlock]:
        """
        Process a single block, including nested content.

        Args:
            block (Dict): Notion block to process
            base_url (str): Base URL of the page

        Returns:
            Optional[NotionBlock]: Processed block

        Raises:
            NotionContentError: If block processing fails
        """
        try:
            nested_text = ""
            if block.get('has_children', False):
                nested_blocks = await self.client.blocks.children.list(block_id=block['id'])
                nested_text = self._extract_nested_text(nested_blocks.get('results', []))

            return NotionBlock.from_block_data(block, base_url=base_url, nested_text=nested_text)
        except Exception as e:
            logger.warning(f"Failed to process block: {str(e)}", extra={"block_id": block.get('id')})
            return None

    def _extract_nested_text(self, children: List[Dict]) -> str:
        """
        Extract text from child blocks.

        Args:
            children (List[Dict]): List of child blocks

        Returns:
            str: Concatenated text from child blocks
        """
        texts = []
        supported_types = ['paragraph', 'bulleted_list_item', 'heading_1', 'heading_2', 'heading_3']

        for child in children:
            block_type = child['type']
            if block_type in supported_types:
                try:
                    text = child[block_type]['rich_text'][0]['text']['content']
                    texts.append(text)
                except (KeyError, IndexError):
                    continue

        return "\n".join(texts)

    @handle_exceptions({
        ValidationError: (400, "Invalid page ID or URL"),
        NotionAuthenticationError: (401, "Failed to authenticate with Notion"),
        ResourceNotFoundError: (404, "Notion page not found"),
        NotionError: (502, "Error processing Notion content"),
        ExternalServiceError: (502, "Error communicating with Notion API")
    })
    async def get_page_content(self, page_id_or_url: str) -> NotionPage:
        """
        Retrieve and process all content from a Notion page.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            NotionPage: Processed page content

        Raises:
            Various exceptions based on the error type
        """
        page_id = self.extract_page_id(page_id_or_url)
        url = await self.get_page_url(page_id)
        
        if not url:
            raise ResourceNotFoundError("Notion page", page_id)

        try:
            blocks_response = await self.client.blocks.children.list(block_id=page_id)
            results = blocks_response.get('results', [])

            if not results:
                raise NotionContentError("Page has no content", page_id)

            # Process blocks concurrently
            tasks = [self._process_block(block, url) for block in results]
            processed_blocks = await asyncio.gather(*tasks)

            # Filter out None values
            valid_blocks = [block for block in processed_blocks if block is not None]

            if not valid_blocks:
                raise NotionContentError("No valid blocks found in page", page_id)

            return NotionPage(id=page_id, url=url, blocks=valid_blocks)

        except APIResponseError as e:
            if e.status == 401:
                raise NotionAuthenticationError()
            elif e.status == 404:
                raise ResourceNotFoundError("Notion page", page_id)
            else:
                raise ExternalServiceError("Notion", str(e), {"status": e.status})
        except Exception as e:
            raise NotionError(str(e), {"page_id": page_id})

    @handle_exceptions({
        NotionError: (502, "Failed to get flashcards from Notion")
    })
    async def get_flashcards(self, page_id_or_url: str) -> List[Dict[str, str]]:
        """
        Get page content in flashcard format.

        Args:
            page_id_or_url (str): Notion page ID or URL

        Returns:
            List[Dict[str, str]]: List of flashcard dictionaries
        """
        page = await self.get_page_content(page_id_or_url)
        return page.to_flashcard_format
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/factory.py`:

```py
from typing import Dict, Type

from .base import ChatBot
from .exceptions import ChatBotNotFoundError
from .providers.groq import GroqChatBot
from .providers.mistral import MistralChatBot


class ChatBotFactory:
    """Factory class for creating chatbot instances"""

    _chatbots: Dict[str, Type[ChatBot]] = {'groq': GroqChatBot, 'mistral': MistralChatBot}

    @classmethod
    async def create(cls, chatbot_type: str) -> ChatBot:
        """
        Create and initialize a chatbot instance

        Args:
            chatbot_type: The type of chatbot to create

        Returns:
            An initialized chatbot instance

        Raises:
            ChatBotNotFoundError: If the requested chatbot type is not supported
        """
        chatbot_class = cls._chatbots.get(chatbot_type.lower())
        if not chatbot_class:
            raise ChatBotNotFoundError(
                f"Unsupported chatbot type: {chatbot_type}. " f"Available types: {list(cls._chatbots.keys())}"
            )

        chatbot = chatbot_class()
        await chatbot.initialize()
        return chatbot

    @classmethod
    def register_chatbot(cls, name: str, chatbot_class: Type[ChatBot]) -> None:
        """
        Register a new chatbot type

        Args:
            name: The name to register the chatbot under
            chatbot_class: The chatbot class to register
        """
        cls._chatbots[name.lower()] = chatbot_class

    @classmethod
    def get_available_chatbots(cls) -> list[str]:
        """Get a list of all available chatbot types"""
        return list(cls._chatbots.keys())

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/exceptions.py`:

```py
class ChatBotError(Exception):
    """Base exception for all chatbot-related errors"""

    pass


class ChatBotNotFoundError(ChatBotError):
    """Raised when a requested chatbot type is not found"""

    pass


class ChatBotInitializationError(ChatBotError):
    """Raised when a chatbot fails to initialize"""

    pass


class ChatBotAPIError(ChatBotError):
    """Raised when there's an error communicating with the chatbot API"""

    pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/base.py`:

```py
import logging
import re
from abc import ABC, abstractmethod
from functools import wraps
from typing import Optional

logger = logging.getLogger(__name__)


def handle_errors(
    default_return_value: Optional[str] = None,
    exceptions: tuple = (Exception,),
    message: str = "Error in chatbot operation",
):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except exceptions as e:
                logger.error(f"{message}: {str(e)}")
                return default_return_value

        return wrapper

    return decorator


class ChatBot(ABC):
    """Abstract base class for all chatbot implementations"""

    @abstractmethod
    async def initialize(self) -> None:
        """Initialize any necessary clients or resources"""
        pass

    @abstractmethod
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        """Generate a summary from the given prompt"""
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup any resources"""
        pass

    @handle_errors(exceptions=(AttributeError, IndexError), message="Error processing response")
    async def process_response(self, response) -> Optional[str]:
        """
        Process the API response, returning None if the summary is invalid or empty.
        """
        if not response or not hasattr(response, 'choices'):
            return None

        content = response.choices[0].message.content
        if not content:
            return None

        pattern = r"\[\[(.*?)\]\]"  # Matches the content within [[ ]]
        find_match = re.findall(pattern, content)

        if find_match:
            summary = find_match[0].strip()
            return summary if summary else None
        else:
            # If no brackets found, use the whole content if it's not empty
            content = content.strip()
            return content if content else None

    async def __aenter__(self):
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/providers/mistral.py`:

```py
from typing import Optional

from mistralai import Mistral

from src.core.config import settings

from ..base import ChatBot, handle_errors


class MistralChatBot(ChatBot):
    def __init__(self):
        self.client: Optional[Mistral] = None
        self.default_model = "mistral-large-latest"

    async def initialize(self) -> None:
        self.client = Mistral(api_key=settings.mistral_api_key)

    @handle_errors(message="MistralChatBot failed to summarize")
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        if not self.client:
            await self.initialize()

        summary = await self.client.chat.complete_async(
            model=model or self.default_model,
            messages=[{"role": "user", "content": prompt}],
        )
        return await self.process_response(summary)

    async def cleanup(self) -> None:
        pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/domain/chatbot/providers/groq.py`:

```py
from typing import Optional

from groq import AsyncGroq

from src.core.config import settings

from ..base import ChatBot, handle_errors


class GroqChatBot(ChatBot):
    def __init__(self):
        self.client: Optional[AsyncGroq] = None
        self.default_model = "llama-3.1-8b-instant"

    async def initialize(self) -> None:
        self.client = AsyncGroq(api_key=settings.groq_api_key)

    @handle_errors(message="GroqChatBot failed to summarize")
    async def get_summary(self, prompt: str, model: Optional[str] = None) -> str:
        if not self.client:
            await self.initialize()

        summary = await self.client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model=model or self.default_model,
        )
        return await self.process_response(summary)

    async def cleanup(self) -> None:
        if self.client:
            await self.client.close()
            self.client = None

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/__init__.py`:

```py
from .domain.flashcard.service import ChatBot, FlashcardCreator, FlashcardService, rate_limit

__all__ = ['FlashcardCreator', 'ChatBot', 'FlashcardService', 'rate_limit']

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/models/responses.py`:

```py
from typing import Dict, List, Optional

from pydantic import BaseModel


class TaskResponse(BaseModel):
    task_id: str
    status: str
    progress: int
    message: Optional[str]
    details: Optional[Dict]

class FlashcardPreview(BaseModel):
    front: str
    back: str
    tags: List[str] = []

class TaskHistoryResponse(BaseModel):
    tasks: List[TaskResponse]
    total: int
    page: int
    per_page: int
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/main.py`:

```py
from contextlib import asynccontextmanager

import uvicorn
from fastapi import FastAPI, Request
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.middleware.sessions import SessionMiddleware

from src.core.config import settings
from src.core.container import cleanup_dependencies, init_dependencies
from src.domain.chatbot.factory import ChatBotFactory

from ..core.config import settings
from .middleware.rate_limiting import RateLimitMiddleware
from .routes import flashcard_routes, health_routes, websocket_routes


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await init_dependencies()
    yield
    # Shutdown
    await cleanup_dependencies()


def create_app() -> FastAPI:
    """
    Create and configure the FastAPI application.

    Returns:
        FastAPI: Configured application instance
    """
    app = FastAPI(
        title="Flashcard Generator API",
        description="API for generating flashcards from Notion pages",
        version="1.0.0",
        lifespan=lifespan,
    )
    app.add_middleware(SessionMiddleware, secret_key=settings.secret_key)
    # Add middleware
    app.add_middleware(RateLimitMiddleware, calls=settings.rate_limit_calls, period=settings.rate_limit_period)

    # Mount static files and templates
    app.mount("/static", StaticFiles(directory="static"), name="static")

    # Include routers
    app.include_router(flashcard_routes.router, prefix="")
    app.include_router(health_routes.router)
    app.include_router(websocket_routes.router)

    return app


app = create_app()
templates = Jinja2Templates(directory="templates")


@app.get("/")
async def home(request: Request):
    """
    Home route rendering the index page.

    Args:
        request (Request): Incoming HTTP request

    Returns:
        TemplateResponse: Rendered index page
    """
    return templates.TemplateResponse(
        "index.html", {"request": request, "chatbot_types": ChatBotFactory.get_available_chatbots()}
    )


if __name__ == "__main__":
    uvicorn.run("api:app", host="0.0.0.0", port=8000, reload=True, ws="websockets", log_level="info")

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/__init__.py`:

```py
from . import flashcard_routes, health_routes, websocket_routes

__all__ = ['flashcard_routes', 'health_routes', 'websocket_routes']

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/flashcard_routes.py`:

```py
import csv
import logging
import os
import uuid
from datetime import datetime
from typing import Optional, Union

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Response
from pydantic import BaseModel, Field, field_validator

from src.core.auth import get_current_user
from src.core.container import get_task_service
from src.core.error_handling import handle_exceptions
from src.core.exceptions.base import NotionError, ResourceNotFoundError, ValidationError
from src.domain.chatbot.factory import ChatBotFactory
from src.domain.flashcard.service import FlashcardCreator, FlashcardService
from src.domain.notion.factory import create_notion_service
from src.domain.task.service import TaskService
from src.repositories.FlashcardRepository import CSVFlashcardRepository

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

router = APIRouter()


class FlashcardRequest(BaseModel):
    """Request schema for generating flashcards"""

    notion_page: str
    output_path: str = Field("output/flashcards.csv", description="Path to save the flashcards")
    batch_size: int = Field(10, gt=0, le=100)  # Positive integer, max 100
    use_chatbot: bool = Field(False)
    chatbot_type: Optional[str] = Field(None, strip_whitespace=True)

    class Config:
        schema_extra = {
            "example": {
                "notion_page": "page_id_or_url",
                "output_path": "output/flashcards.csv",
                "batch_size": 10,
                "use_chatbot": True,
                "chatbot_type": "groq",
            }
        }

    @field_validator("chatbot_type")
    def validate_chatbot_type(cls, value, values):
        """
        Validate chatbot type when using a chatbot.

        Args:
            value (str): Chatbot type
            values (Dict): Other request values

        Returns:
            str: Validated chatbot type

        Raises:
            ValueError: If chatbot type is invalid
        """
        if values.data.get('use_chatbot'):
            if not value:
                raise ValueError("Chatbot type is required when use_chatbot is True")
            available_chatbots = ChatBotFactory.get_available_chatbots()
            if value not in available_chatbots:
                raise ValueError(f"Invalid chatbot type. Allowed types: {available_chatbots}")
        return value


class FlashcardResponse(BaseModel):
    """Response schema for generating flashcards"""

    message: str
    task_id: str


async def generate_flashcards_task(task_service: TaskService, user_id: str, task_id: str, request: FlashcardRequest):
    """
    Background task for generating flashcards.

    Args:
        task_id (str): Unique identifier for the task
        request (FlashcardRequest): Flashcard generation request details
    """
    try:
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=0, status="starting", message="Initializing components..."
        )
        # Initialize components
        flashcard_repository = CSVFlashcardRepository(anki_output_file=request.output_path)
        notion_service = await create_notion_service()
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=20, status="processing", message="Fetching Notion content..."
        )
        notion_page = await notion_service.get_page_content(request.notion_page)
        notion_content = notion_page.to_flashcard_format

        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=20, status="processing", message="Creating flashcards..."
        )
        flashcard_creator = FlashcardCreator(
            flashcard_repository=flashcard_repository, task_service=task_service, task_id=task_id, user_id=user_id
        )

        # Prepare service with or without chatbot
        async def run_flashcard_service(chatbot=None) -> Union[str, str]:
            """
            Run flashcard service with optional chatbot.

            Args:
                chatbot (Optional[ChatBot]): Chatbot for summary generation
            """
            service = FlashcardService(
                flashcard_creator=flashcard_creator, notion_content=notion_content, chatbot=chatbot
            )
            return await service.run()

        if request.use_chatbot:
            chatbot = await ChatBotFactory.create(request.chatbot_type)
            async with chatbot:
                result_message, result_status = await run_flashcard_service(chatbot)
        else:
            result_message, result_status = await run_flashcard_service()

        logger.info(f"Task {task_id} completed successfully.")

        # Add to history
        await task_service.add_to_history(
            user_id,
            {
                "task_id": task_id,
                "notion_page": notion_page.url,
                "chatbot_type": request.chatbot_type,
                "output_path": request.output_path,
                "timestamp": datetime.now().isoformat(),
                "status": result_status,
            },
        )

    except Exception as e:
        await task_service.update_task_progress(
            user_id=user_id, task_id=task_id, progress=0, status="failed", message=str(e)
        )
        logger.exception(f"Task {task_id} failed")
        raise


@router.post("/generate-flashcards/", response_model=FlashcardResponse)
async def create_flashcards(
    request: FlashcardRequest,
    background_tasks: BackgroundTasks,
    current_user: str = Depends(get_current_user),
    task_service: TaskService = Depends(get_task_service),
):
    """
    Endpoint to initiate flashcard generation.

    Args:
        request (FlashcardRequest): Flashcard generation request details
        background_tasks (BackgroundTasks): FastAPI background tasks manager
        current_user (str): user id
        task_service (TaskService): task_service

    Returns:
        FlashcardResponse: Task initiation response
    """
    try:
        # Generate unique task ID and output path
        task_id = f"task_{uuid.uuid4()}"
        output_path = f"output/flashcards_{task_id}.csv"
        request.output_path = output_path
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        # Create task with initial status
        await task_service.create_task(
            user_id=current_user,
            task_id=task_id,
            initial_data={"status": "created", "output_path": output_path, "request": request.model_dump()},
        )

        # Add flashcard generation to background tasks
        background_tasks.add_task(
            generate_flashcards_task, task_service=task_service, user_id=current_user, task_id=task_id, request=request
        )

        return FlashcardResponse(message="Flashcard generation started", task_id=task_id)
    except Exception as e:
        logger.exception("Failed to initiate flashcard generation")
        raise HTTPException(status_code=500, detail="An error occurred while starting the flashcard generation.")


@router.get("/task-status/{task_id}")
@handle_exceptions({
    ResourceNotFoundError: (404, "Task not found"),
    ValidationError: (400, "Invalid task ID"),
    NotionError: (502, "Error communicating with Notion")
})
async def get_task_status(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Retrieve status of a specific task.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService): task_service

    Returns:
        Dict: Task status information

    Raises:
        HTTPException: If task is not found
    """
    return await task_service.get_task_status(current_user, task_id)


@router.get("/generation-history")
async def get_generation_history(
    current_user: str = Depends(get_current_user),
    limit: int = 50,
    task_service: TaskService = Depends(get_task_service),
):
    """
    Retrieve generation history.

    Returns:
        List[Dict]: List of past generation tasks
    """
    return await task_service.get_user_history(current_user, limit)


@router.get("/preview-flashcards/{task_id}")
async def preview_flashcards(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Preview first 5 generated flashcards.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService): task_service

    Returns:
        List[Dict]: Preview of generated flashcards

    Raises:
        HTTPException: If flashcards are not found or still processing
    """
    task = await task_service.get_task_status(current_user, task_id)
    if not task or task["status"] not in ["completed", "completed_with_errors"]:
        raise HTTPException(status_code=404, detail="Flashcards not found or still processing")
    output_path = f"output/flashcards_{task_id}.csv"
    preview_cards = []
    try:
        with open(output_path, 'r', encoding='utf-8') as f:
            reader = csv.reader(f)
            for i, row in enumerate(reader):
                if i >= 5:  # Preview only first 5 cards
                    break
                preview_cards.append({"front": row[0], "back": row[1]})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    return preview_cards


@router.get("/download/{task_id}")
async def download_flashcards(
    task_id: str, current_user: str = Depends(get_current_user), task_service: TaskService = Depends(get_task_service)
):
    """
    Download generated flashcards CSV file.

    Args:
        task_id (str): Unique identifier for the task
        task_service (TaskService) : task_service

    Returns:
        Response: CSV file download

    Raises:
        HTTPException: If flashcards are not found or an error occurs
    """
    task = await task_service.get_task_status(current_user, task_id)
    if not task or task["status"] not in ["completed", "completed_with_errors"]:
        raise HTTPException(status_code=404, detail="Flashcards not found or still processing")
    output_path = f"output/flashcards_{task_id}.csv"
    try:
        with open(output_path, 'rb') as f:
            content = f.read()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    return Response(
        content=content,
        media_type='text/csv',
        headers={'Content-Disposition': f'attachment; filename="flashcards_{task_id}.csv"'},
    )

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/health_routes.py`:

```py
from fastapi import APIRouter, Request

from monitoring.health import HealthCheck

router = APIRouter()


@router.get("/health")
async def health_check(request: Request):
    """
    Perform system health check.

    Args:
        request (Request): Incoming HTTP request

    Returns:
        Dict: Health check results
    """
    async with HealthCheck() as health_check:
        return await health_check.get_health(request)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/routes/websocket_routes.py`:

```py
import logging
from typing import Optional

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect

from ...common.websocket import WebSocketManager
from ...core.container import get_websocket_manager

logger = logging.getLogger(__name__)
router = APIRouter()


@router.websocket("/ws/{task_id}")
async def websocket_endpoint(
    websocket: WebSocket, task_id: str, websocket_manager: WebSocketManager = Depends(get_websocket_manager)
):
    """
    WebSocket endpoint for real-time task progress updates.

    Args:
        websocket (WebSocket): WebSocket connection
        task_id (str): Unique identifier for the task
        websocket_manager(WebSocketManager): WebSocket connections manager for task progress tracking
    """
    try:
        await websocket_manager.connect(task_id, websocket)
        while True:
            try:
                await websocket.receive_text()
            except WebSocketDisconnect:
                logger.info(f"WebSocket disconnected for task {task_id}")
                break
            except Exception as e:
                logger.error(f"WebSocket error for task {task_id}: {str(e)}")
                break
    finally:
        websocket_manager.disconnect(task_id)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/api/middleware/rate_limiting.py`:

```py
import time
from collections import defaultdict

from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware for rate limiting API requests"""

    def __init__(self, app, calls: int, period: int):
        super().__init__(app)
        self.calls = calls
        self.period = period
        self.requests = defaultdict(list)

    async def dispatch(self, request: Request, call_next) -> Response:
        """
        Dispatch the request to the next middleware or the endpoint handler.
        Only apply rate limiting to the generate-flashcards endpoint
        """
        if request.url.path == "/generate-flashcards/":
            client_ip = request.headers.get("X-Forwarded-For")
            if client_ip is None:
                # Handle the case where client_ip is None
                client_ip = "127.0.0.1"

            current_time = time.time()

            # Remove outdated requests
            self.requests[client_ip] = [t for t in self.requests[client_ip] if t > current_time - self.period]

            if len(self.requests[client_ip]) >= self.calls:
                return JSONResponse(status_code=429, content={"error": "Rate limit exceeded"})

            self.requests[client_ip].append(current_time)

        response = await call_next(request)
        return response

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/websocket.py`:

```py
import logging
from typing import Dict

from fastapi import WebSocket

logger = logging.getLogger(__name__)


class WebSocketManager:
    """Manages WebSocket connections for task progress tracking."""

    def __init__(self):
        """Initialize WebSocket connections dictionary."""
        self.connections: Dict[str, WebSocket] = {}
        logger.info("WebSocketManager initialized")

    async def connect(self, task_id: str, websocket: WebSocket):
        """
        Establish a WebSocket connection for a specific task.

        Args:
            task_id (str): Unique identifier for the task
            websocket (WebSocket): WebSocket connection
        """
        try:
            await websocket.accept()
            self.connections[task_id] = websocket
            logger.info(f"WebSocket connection established for task {task_id}")
        except Exception as e:
            logger.error(f"Failed to establish WebSocket connection for task {task_id}: {str(e)}")
            raise

    def disconnect(self, task_id: str):
        """
        Remove a WebSocket connection.

        Args:
            task_id (str): Unique identifier for the task
        """
        if task_id in self.connections:
            self.connections.pop(task_id)
            logger.info(f"WebSocket connection removed for task {task_id}")

    async def send_progress(self, task_id: str, progress_data: Dict):
        """
        Send progress update to a specific WebSocket connection.

        Args:
            task_id (str): Unique identifier for the task
            progress_data (Dict): Progress update information
        """
        if task_id in self.connections:
            try:
                websocket = self.connections[task_id]
                await websocket.send_json(progress_data)
                logger.debug(f"Progress update sent for task {task_id}: {progress_data}")
            except Exception as e:
                logger.error(f"Failed to send progress update for task {task_id}: {str(e)}")
                self.disconnect(task_id)

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/error_handling.py`:

```py
import logging
from functools import wraps
from typing import Callable, Optional

logging.basicConfig(level=logging.ERROR)


class AppError(Exception):
    """Base application-specific exception"""

    def __init__(self, message: str, context: Optional[dict] = None):
        self.message = message
        self.context = context or {}
        super().__init__(self.message)


class ConfigurationError(AppError):
    """Raised when there's a configuration-related issue"""

    pass


class ExternalServiceError(AppError):
    """Raised when an external service (like Notion) fails"""

    pass


def handle_errors_decorator(
    default_return_value=None, exceptions=(Exception,), message="An error occurred"
) -> Callable:
    """
    Decorator for handling errors in a function.

    Args:
        default_return_value (Any, optional): The default return value if an error occurs. Defaults to None.
        exceptions (tuple, optional): The exceptions to catch. Defaults to (Exception,).
        message (str, optional): The message to log if an error occurs. Defaults to "An error occurred".

    Returns:
        Callable: The decorated function.
    """

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except exceptions as e:
                logging.error(f"{message} in {func.__name__}: {e}")
                return default_return_value

        return wrapper

    return decorator


import logging
from functools import wraps
from typing import Any, Callable, List, Optional, Type


class AppError(Exception):
    """Base application-specific exception"""

    def __init__(self, message: str, context: Optional[dict] = None):
        self.message = message
        self.context = context or {}
        super().__init__(self.message)


class ConfigurationError(AppError):
    """Raised when there's a configuration-related issue"""

    pass


class ExternalServiceError(AppError):
    """Raised when an external service (like Notion) fails"""

    pass


def handle_errors(
    logger: logging.Logger,
    default_return: Any = None,
    exceptions: List[Type[Exception]] = None,
    error_type: Optional[Type[AppError]] = None,
) -> Callable:
    """
    Advanced error handling decorator with more robust logging and error tracking

    Args:
        logger: Logging instance to use
        default_return: Value to return if an error occurs
        exceptions: List of specific exceptions to catch
        error_type: Custom error type to raise
    """
    exceptions = exceptions or [Exception]

    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except tuple(exceptions) as e:
                # Detailed error logging
                error_details = {'function': func.__name__, 'module': func.__module__, 'args': args, 'kwargs': kwargs}

                # Log the error with context
                logger.error(f"Error in {func.__name__}: {str(e)}", extra={'error_details': error_details})

                # Optionally raise a custom error type
                if error_type:
                    raise error_type(message=str(e), context=error_details) from e

                return default_return

        return wrapper

    return decorator

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/common/errors.py`:

```py
class AppError(Exception):
    """Base application exception"""

    pass


class ValidationError(AppError):
    """Raised when input validation fails"""

    pass


class NotionError(AppError):
    """Raised when Notion API operations fail"""

    pass


class FlashcardError(AppError):
    """Raised when flashcard operations fail"""

    pass


class ChatBotError(AppError):
    """Raised when chatbot operations fail"""

    pass

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/error_handling.py`:

```py
import logging
from functools import wraps
from typing import Callable, Dict, Optional, ParamSpec, Type, TypeVar

from fastapi import HTTPException

from .exceptions.base import AppError

logger = logging.getLogger(__name__)

P = ParamSpec("P")
T = TypeVar("T")

ErrorMapping = Dict[Type[Exception], tuple[int, str]]

DEFAULT_ERROR_MAPPING: ErrorMapping = {
    AppError: (500, "Internal application error"),
    ValueError: (400, "Invalid input"),
    KeyError: (404, "Resource not found"),
    Exception: (500, "Internal server error"),
}


def handle_exceptions(
    error_mapping: Optional[ErrorMapping] = None,
    log_level: int = logging.ERROR,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    Advanced exception handler with error mapping and logging
    
    Args:
        error_mapping: Custom mapping of exceptions to (status_code, message)
        log_level: Logging level for errors
    
    Usage:
        @handle_exceptions({
            ValidationError: (400, "Invalid input"),
            ResourceNotFoundError: (404, "Resource not found"),
            NotionError: (502, "Notion API error")
        })
        async def my_function():
            ...
    """
    combined_mapping = {**DEFAULT_ERROR_MAPPING, **(error_mapping or {})}
    
    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @wraps(func)
        async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                # Find the most specific matching exception type
                for exc_type, (status_code, message) in combined_mapping.items():
                    if isinstance(e, exc_type):
                        # Log the error with context
                        log_data = {
                            "function": func.__name__,
                            "module": func.__module__,
                            "args": str(args),
                            "kwargs": str(kwargs),
                            "exception_type": type(e).__name__,
                        }

                        if isinstance(e, AppError):
                            log_data.update({
                                "error_code": e.error_code,
                                "details": e.details,
                            })
                            error_response = {
                                "message": message,
                                "error_code": e.error_code,
                                "details": e.details
                            }
                        else:
                            error_response = {"message": message}

                        logger.log(log_level, str(e), extra=log_data)
                        raise HTTPException(status_code=status_code, detail=error_response)
                
                # If no matching exception type is found, raise a generic 500 error
                logger.exception("Unhandled exception in %s", func.__name__)
                raise HTTPException(status_code=500, detail={"message": "Internal server error"})
                
        return wrapper
    return decorator


def handle_service_errors(
    default_return_value: Optional[T] = None,
    error_mapping: Optional[ErrorMapping] = None,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    Error handler for service layer operations that should not raise HTTP exceptions
    
    Args:
        default_return_value: Value to return on error
        error_mapping: Custom mapping of exceptions to handler functions
    """
    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @wraps(func)
        async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                log_data = {
                    "function": func.__name__,
                    "module": func.__module__,
                    "args": str(args),
                    "kwargs": str(kwargs),
                    "exception_type": type(e).__name__,
                }

                if isinstance(e, AppError):
                    log_data.update({
                        "error_code": e.error_code,
                        "details": e.details,
                    })

                logger.error(str(e), extra=log_data)
                return default_return_value

        return wrapper
    return decorator
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/exceptions/domain.py`:

```py
from typing import Dict, Optional

from .base import AppError


class NotionError(AppError):
    """Notion-related errors"""
    def __init__(self, message: str, details: Optional[Dict] = None):
        super().__init__(message, "NOTION_ERROR", details)


class NotionAuthenticationError(NotionError):
    """Notion authentication errors"""
    def __init__(self):
        super().__init__("Failed to authenticate with Notion API")


class NotionContentError(NotionError):
    """Notion content processing errors"""
    def __init__(self, message: str, page_id: str):
        super().__init__(message, {"page_id": page_id})


class ChatBotError(AppError):
    """Chatbot-related errors"""
    def __init__(self, message: str, bot_type: str, details: Optional[Dict] = None):
        super().__init__(
            message=message,
            error_code="CHATBOT_ERROR",
            details={"bot_type": bot_type, **(details or {})}
        )


class FlashcardError(AppError):
    """Flashcard-related errors"""
    def __init__(self, message: str, details: Optional[Dict] = None):
        super().__init__(message, "FLASHCARD_ERROR", details)


class TaskError(AppError):
    """Task-related errors"""
    def __init__(self, message: str, task_id: str, details: Optional[Dict] = None):
        super().__init__(
            message=message,
            error_code="TASK_ERROR",
            details={"task_id": task_id, **(details or {})}
        )
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/exceptions/base.py`:

```py
from typing import Dict, Optional


class AppError(Exception):
    """Base exception class for application-specific errors"""
    def __init__(self, message: str, error_code: str, details: Optional[Dict] = None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)


class ValidationError(AppError):
    """Validation error"""
    def __init__(self, message: str, field: str):
        super().__init__(
            message=message,
            error_code="VALIDATION_ERROR",
            details={"field": field}
        )


class ResourceNotFoundError(AppError):
    """Resource not found error"""
    def __init__(self, resource_type: str, resource_id: str):
        super().__init__(
            message=f"{resource_type} not found: {resource_id}",
            error_code="RESOURCE_NOT_FOUND",
            details={"resource_type": resource_type, "resource_id": resource_id}
        )


class ConfigurationError(AppError):
    """Configuration-related errors"""
    def __init__(self, message: str, details: Optional[Dict] = None):
        super().__init__(message, "CONFIGURATION_ERROR", details)


class ExternalServiceError(AppError):
    """External service communication errors"""
    def __init__(self, service: str, message: str, details: Optional[Dict] = None):
        super().__init__(
            message=f"{service} service error: {message}",
            error_code="EXTERNAL_SERVICE_ERROR",
            details={"service": service, **(details or {})}
        )
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/container.py`:

```py
# src/dependencies/container.py
import asyncio
import logging
from typing import Optional

from redis.asyncio import Redis, RedisCluster
from redis.asyncio.cluster import ClusterNode

from src.common.websocket import WebSocketManager
from src.core.config import settings
from src.domain.task.service import TaskService

logger = logging.getLogger(__name__)


class RedisConnection:
    """Singleton Redis connection manager."""

    _instance: Optional[Redis] = None
    _lock: asyncio.Lock = asyncio.Lock()

    @classmethod
    async def get_connection(cls) -> Redis:
        """Get or create Redis connection."""
        async with cls._lock:
            if cls._instance is None:
                try:
                    if settings.environment == "production":
                        nodes = [ClusterNode(host, port) for host, port in settings.redis_cluster_nodes]
                        cls._instance = RedisCluster(
                            startup_nodes=nodes, decode_responses=True, max_connections=settings.redis_max_connections
                        )
                    else:
                        cls._instance = Redis(
                            host=settings.redis_host,
                            port=settings.redis_port,
                            decode_responses=True,
                            max_connections=settings.redis_max_connections,
                        )
                    # Verify connection
                    await cls._instance.ping()
                    logger.info("Redis connection established successfully")
                except Exception as e:
                    logger.error(f"Failed to establish Redis connection: {e}")
                    raise
            return cls._instance

    @classmethod
    async def close(cls):
        """Close Redis connection."""
        if cls._instance:
            await cls._instance.close()
            cls._instance = None
            logger.info("Redis connection closed")


class DependencyContainer:
    """Singleton container for application-wide dependencies."""

    _instance: Optional['DependencyContainer'] = None
    _websocket_manager: Optional[WebSocketManager] = None
    _task_service: Optional[TaskService] = None
    _redis: Optional[Redis] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._websocket_manager = WebSocketManager()
        return cls._instance

    @classmethod
    def get_websocket_manager(cls) -> WebSocketManager:
        """Get or create WebSocketManager instance."""
        if cls._websocket_manager is None:
            cls._websocket_manager = WebSocketManager()
            logger.info("Created new WebSocketManager instance")
        return cls._websocket_manager

    @classmethod
    async def get_task_service(cls) -> TaskService:
        """Get or create TaskService instance with shared WebSocketManager."""
        if cls._task_service is None:
            websocket_manager = cls.get_websocket_manager()
            redis = await RedisConnection.get_connection()
            cls._task_service = TaskService(redis=redis, websocket_manager=websocket_manager)
            logger.info("Created new TaskService instance")
        return cls._task_service


# FastAPI dependencies
async def get_redis() -> Redis:
    """Dependency for getting Redis connection."""
    return await RedisConnection.get_connection()


async def get_websocket_manager() -> WebSocketManager:
    """Dependency for getting WebSocketManager instance."""
    return DependencyContainer.get_websocket_manager()


async def get_task_service() -> TaskService:
    """Dependency for getting TaskService instance."""
    return await DependencyContainer.get_task_service()


# Application lifecycle management
async def init_dependencies():
    """Initialize application dependencies."""
    try:
        logger.info("Initializing application dependencies...")
        await RedisConnection.get_connection()
        await DependencyContainer.get_task_service()
        logger.info("Dependencies initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize dependencies: {e}")
        raise


async def cleanup_dependencies():
    """Cleanup application dependencies."""
    try:
        logger.info("Cleaning up application dependencies...")
        await RedisConnection.close()
        logger.info("Dependencies cleaned up successfully")
    except Exception as e:
        logger.error(f"Error during dependency cleanup: {e}")
        raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/auth.py`:

```py
import uuid

from fastapi import Request


async def get_current_user(request: Request) -> str:

    user_id = request.session.get("user_id")
    if not user_id:
        user_id = str(uuid.uuid4())
        request.session["user_id"] = user_id
    return user_id

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/logging.py`:

```py
import json
import logging
from typing import Any, Dict


class JSONFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:
        log_data: Dict[str, Any] = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
        }
        
        if hasattr(record, "error_code"):
            log_data["error_code"] = record.error_code
            
        if hasattr(record, "details"):
            log_data["details"] = record.details
            
        return json.dumps(log_data)

def setup_logging() -> None:
    logger = logging.getLogger()
    handler = logging.StreamHandler()
    handler.setFormatter(JSONFormatter())
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/core/config.py`:

```py
import secrets
from typing import List, Tuple

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    notion_api_key: str = Field(..., env="NOTION_API_KEY", description="API Key for Notion service")
    groq_api_key: str = Field(..., env="GROQ_API_KEY", description="API Key for Groq chatbot service")
    mistral_api_key: str = Field(..., env="MISTRAL_API_KEY", description="API Key for Mistral chatbot service")
    max_retries: int = Field(3, description="Maximum number of retries for API calls")
    rate_limit_calls: int = Field(5, description="Rate limit - maximum calls allowed in the specified period")
    rate_limit_period: int = Field(60, description="Rate limit time period in seconds")
    cache_expiry: int = Field(3600, description="Cache expiry duration in seconds")
    cache_maxsize: int = Field(100, description="Cache maximum size")
    environment: str = Field("development", description="Environment for task tracking")
    secret_key: str = Field(secrets.token_urlsafe(32), description="Secret key for session management")
    redis_cluster_nodes: List[Tuple[str, int]] = Field(
        [("localhost", 7001), ("localhost", 7002), ("localhost", 7003)], description="Redis cluster node IP addresses"
    )
    redis_host: str = Field("localhost", description="Redis host")
    redis_port: int = Field(6379, description="Redis port")
    redis_max_connections: int = Field(10, description="Redis max connections")

    @field_validator('notion_api_key', 'groq_api_key', 'mistral_api_key')
    def validate_api_keys(cls, v: str) -> str:
        """
        Validate that API keys are not empty and meet basic length criteria.
        """
        if not v or len(v.strip()) < 10:
            raise ValueError("The API key appears to be invalid or too short.")
        return v

    class Config:
        # Automatically load the settings from environment variables
        env_file = ".env"
        env_file_encoding = "utf-8"

class RedisSettings(BaseSettings):
    host: str = Field(..., env="REDIS_HOST")
    port: int = Field(..., env="REDIS_PORT")
    max_connections: int = Field(10, env="REDIS_MAX_CONNECTIONS")

    @field_validator("max_connections")
    def validate_max_connections(cls, v: int) -> int:
        if v < 1 or v > 100:
            raise ValueError("max_connections must be between 1 and 100")
        return v

class AppSettings(BaseSettings):
    redis: RedisSettings
    debug: bool = Field(False, env="DEBUG")
    environment: str = Field("development", env="ENVIRONMENT")


# Create a settings instance
settings = Settings()

# Export settings instance
__all__ = ['settings']

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/src/repositories/FlashcardRepository.py`:

```py
import csv
import logging
import os
from abc import ABC, abstractmethod
from typing import Generic, TypeVar

import aiofiles

from src.domain.flashcard.models import Flashcard

# Generic type for repository
T = TypeVar('T')


class FlashcardRepositoryInterface(ABC, Generic[T]):
    """Abstract base class defining the interface for Flashcard repositories."""

    @abstractmethod
    async def get_existing_flashcards(self) -> set:
        """
        Retrieve a set of existing flashcards.

        Returns:
            set: A set of existing flashcard identifiers.
        """
        pass

    @abstractmethod
    async def save_flashcard(self, item: T) -> None:
        """
        Save a single flashcard.

        Args:
            item (T): The flashcard to be saved.
        """
        pass


class CSVFlashcardRepository(FlashcardRepositoryInterface):
    """Concrete implementation of a CSV-based Flashcard repository."""

    def __init__(self, anki_output_file: str):
        """
        Initialize the CSV Flashcard Repository.

        Args:
            anki_output_file (str): Path to the output CSV file.
        """
        self.anki_output_file = anki_output_file
        self.logger = logging.getLogger(__name__)

    async def get_existing_flashcards(self) -> set:
        """
        Load existing flashcards from the CSV file.

        Returns:
            set: A set of existing flashcard front texts.
        """
        existing_flashcards = set()

        if not os.path.exists(self.anki_output_file):
            return existing_flashcards

        try:
            async with aiofiles.open(self.anki_output_file, mode="r", encoding="utf-8") as file:
                content = await file.read()
                reader = csv.reader(content.splitlines())
                existing_flashcards = {row[0] for row in reader if row}

            self.logger.info(f"Loaded {len(existing_flashcards)} existing flashcards")
        except Exception as e:
            self.logger.error(f"Error loading existing flashcards: {str(e)}")

        return existing_flashcards

    async def save_flashcard(self, item: Flashcard) -> None:
        """
        Save a single flashcard to the CSV file.

        Args:
            item (Flashcard): The flashcard to be saved.

        Raises:
            Exception: If there's an error during file writing.
        """
        try:
            async with aiofiles.open(self.anki_output_file, mode="a", encoding="utf-8", newline="") as file:
                writer = csv.writer(file)
                await writer.writerow([item.front, item.back])
                self.logger.info(f"Flashcard with front: '{item.front[:50]}...' created!")
        except Exception as e:
            self.logger.error(f"Error saving flashcard: {str(e)}")
            raise

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/api.txt`:

```txt
fastapi>=0.115.5
uvicorn[standard]>=0.32.1
starlette>=0.41.3
python-multipart>=0.0.6
jinja2>=3.1.2
aiofiles==23.2.1

```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/test.txt`:

```txt
pytest==8.3.3
pytest-cov==6.0.0
pytest-mock==3.14.0
pytest-asyncio==0.24.0
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/dev.txt`:

```txt
isort
black
pre-commit
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/requirements/base.txt`:

```txt
notion-client==2.2.1
mistralai==1.2.3
groq==0.12.0
pydantic==2.9.2
cachetools==5.5.0
tenacity==9.0.0
pydantic_settings==2.6.1
wsproto==1.2.0
redis==5.2.0
```

`/home/mehrdad/Documents/VSCodeProjects/MyProjects/ai-tools/tests/test_flashcard.py`:

```py
import unittest
from unittest.mock import Mock, patch

import pytest
from fastapi import HTTPException
from fastapi.testclient import TestClient

from src.api.main import app
from src.api.routes.flashcard_routes import (
    FlashcardRequest,
    FlashcardResponse,
    generate_flashcards_task,
    update_task_progress,
)

client = TestClient(app)


@pytest.fixture
def mock_notion_content():
    return Mock()


@pytest.fixture
def mock_chatbot():
    chatbot = Mock(spec=["get_summary"])
    chatbot.get_summary.return_value = "This is a test summary"
    return chatbot


@pytest.fixture
def mock_repository():
    repository = Mock(spec=["save_flashcard", "get_existing_flashcards"])
    repository.save_flashcard.return_value = None
    return repository


class TestFlashcardCreator:

    async def test_validate_flashcard_content(self, mock_repository):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)

        # Test valid cases
        assert creator.validate_flashcard_content("Valid content") == True
        assert creator.validate_flashcard_content("ABC") == True

        # Test invalid cases
        assert creator.validate_flashcard_content("") == False
        assert creator.validate_flashcard_content("ab") == False
        assert creator.validate_flashcard_content("a" * 501) == False
        assert creator.validate_flashcard_content(None) == False
        assert creator.validate_flashcard_content(123) == False

    @unittest.skip("Skipping test_get_cached_summary")
    async def test_get_cached_summary(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)

        # Test first call (cache miss)
        result1 = await creator.get_cached_summary("test prompt", mock_chatbot)
        assert result1 == "This is a test summary"
        mock_chatbot.get_summary.assert_called_once()

        # Test second call (cache hit)
        mock_chatbot.get_summary.reset_mock()
        result2 = await creator.get_cached_summary("test prompt", mock_chatbot)
        assert result2 == "This is a test summary"
        mock_chatbot.get_summary.assert_not_called()

    @pytest.mark.parametrize(
        "test_input,expected",
        [
            ([], 0),  # Empty list
            ([{"text": "test", "url": "http://test.com"}], 1),  # Single item
            ([{"text": "test1", "url": "url1"}, {"text": "test2", "url": "url2"}], 2),  # Multiple items
        ],
    )
    @unittest.skip("Skipping test_create_flashcards")
    async def test_create_flashcards(self, test_input, expected, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)
        await creator.create_flashcards(test_input, mock_chatbot)
        assert mock_repository.save_flashcard.call_count == expected

    @unittest.skip("Skipping test_create_flashcards_with_existing_cards")
    async def test_create_flashcards_with_existing_cards(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        mock_repository.get_existing_flashcards.return_value = {"test1"}
        creator = FlashcardCreator(mock_repository)

        input_data = [
            {"front": "test1", "back": "url1"},  # Should be skipped
            {"front": "test2", "back": "url2"},  # Should be processed
        ]

        await creator.create_flashcards(input_data, mock_chatbot)
        assert mock_repository.save_flashcard.call_count == 1

    async def test_error_handling(self, mock_repository, mock_chatbot):
        from src.domain.flashcard.service import FlashcardCreator

        creator = FlashcardCreator(mock_repository)
        mock_chatbot.get_summary.side_effect = Exception("API Error")

        with pytest.raises(Exception):
            await creator.get_cached_summary("test prompt", mock_chatbot)


class TestFlashcardService(unittest.TestCase):

    async def test_service_initialization(self, mock_notion_content, mock_chatbot, mock_repository):
        from src.domain.flashcard.service import FlashcardCreator, FlashcardService

        creator = FlashcardCreator(mock_repository)
        service = FlashcardService(notion_content=mock_notion_content, chatbot=mock_chatbot, flashcard_creator=creator)
        assert service.notion_content == mock_notion_content
        assert service.chatbot == mock_chatbot
        assert service.flashcard_creator == creator

    async def test_service_run(self):
        with patch('src.flashcard.notion_content') as mock_notion_content:
            with patch('src.flashcard.chatbot') as mock_chatbot:
                with patch('src.flashcard.repository') as mock_repository:
                    from src.domain.flashcard.service import FlashcardCreator, FlashcardService

                    creator = FlashcardCreator(mock_repository)
                    service = FlashcardService(
                        notion_content=mock_notion_content, chatbot=mock_chatbot, flashcard_creator=creator
                    )
                    await service.run()
                    assert mock_repository.save_flashcard.call_count == 2


class TestAPI(unittest.TestCase):
    async def test_create_flashcards_endpoint(self):
        response = client.post(
            "/generate-flashcards/",
            json={"notion_page_id": "test-page", "use_chatbot": False, "output_path": "test.csv"},
        )
        assert response.status_code == 200
        assert "task_id" in response.json()

    async def test_create_flashcards_with_chatbot(self):
        response = client.post(
            "/generate-flashcards/",
            json={
                "notion_page_id": "test-page",
                "use_chatbot": True,
                "chatbot_type": "groq",
                "output_path": "test.csv",
            },
        )
        assert response.status_code == 200
        assert "task_id" in response.json()

    async def test_create_flashcards_invalid_chatbot_type(self):
        response = client.post(
            "/generate-flashcards/",
            json={
                "notion_page_id": "test-page",
                "use_chatbot": True,
                "chatbot_type": "invalid_type",
                "output_path": "test.csv",
            },
        )
        assert response.status_code == 422

    async def test_get_task_status(self):
        # Mock the client.get method
        client.get = Mock(return_value=Mock(status_code=404))

        # Make a GET request to /task-status/{task_id}
        task_id = "some_task_id"
        response = client.get(f"/task-status/{task_id}")

        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)

```